> [9. Metodolog√≠a de Dise√±o de Arquitectura - Aplicaci√≥n de ADD](../../9.md) ‚Ä∫ [9.3. Iteraci√≥n 2: Identificar estructuras para soportar la funcionalidad primaria](../9.3.md) ‚Ä∫ [9.3.3. Conceptos de dise√±o](9.3.3.md)

# 9.3.3. Conceptos de dise√±o

## Conceptos de Dise√±o

Esta secci√≥n documenta los patrones y conceptos de dise√±o aplicados para descomponer los microservicios en componentes internos.

---

### 1. Patr√≥n: Layered Architecture (Arquitectura en Capas)

#### Descripci√≥n

Organiza el c√≥digo en capas horizontales, donde cada capa tiene una responsabilidad espec√≠fica y solo puede depender de capas inferiores.

#### Capas Aplicadas en NEXUS

![Capas Aplicadas en NEXUS](./diagrama/CAPAS.png)

| Capa | Responsabilidad | Tecnolog√≠a NestJS |
|---|---|---|
| **Presentaci√≥n** | Manejo de peticiones HTTP/WebSocket | `@Controller()`, `@WebSocketGateway()` |
| **Aplicaci√≥n** | L√≥gica de negocio y orquestaci√≥n | `@Injectable()` Services |
| **Dominio** | Modelos y reglas de negocio | Classes, Interfaces, DTOs |
| **Infraestructura** | Acceso a datos y servicios externos | Repositories, Adapters con `@Injectable()` |

#### Beneficios

- **Separaci√≥n de Responsabilidades**: Cada capa tiene un prop√≥sito claro
- **Testabilidad**: Capas pueden ser testeadas independientemente
- **Mantenibilidad**: Cambios en una capa no afectan otras (ESC-06)
- **Reusabilidad**: Services pueden ser reutilizados por m√∫ltiples Controllers

---

### 2. Patr√≥n: Repository Pattern

#### Descripci√≥n

Abstrae el acceso a datos mediante una interfaz, desacoplando la l√≥gica de negocio de la tecnolog√≠a de persistencia.

#### Implementaci√≥n en NEXUS

```typescript
// Interfaz del repositorio
interface IUserRepository {
  findById(id: string): Promise<User>;
  findByEmail(email: string): Promise<User>;
  create(user: CreateUserDto): Promise<User>;
  update(id: string, data: UpdateUserDto): Promise<User>;
}

// Implementaci√≥n para PostgreSQL
@Injectable()
class UserRepository implements IUserRepository {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}
  
  async findById(id: string): Promise<User> {
    return this.repo.findOne({ where: { id } });
  }
  // ...
}
```

#### Beneficios

- **Abstracci√≥n**: Services no conocen detalles de la BD
- **Testabilidad**: F√°cil crear mocks de repositorios
- **Cambio de BD**: Cambiar implementaci√≥n sin afectar Services

---

### 3. Patr√≥n: Adapter Pattern (Hexagonal Architecture)

#### Descripci√≥n

Encapsula la integraci√≥n con servicios externos mediante adaptadores, permitiendo cambiar proveedores sin afectar la l√≥gica de negocio.

#### Adaptadores en NEXUS

![Adaptadores en NEXUS](./diagrama/ADAPTADOR.png)

**Ejemplo de Adaptador**:

```typescript
// Interfaz
interface IEmailAdapter {
  sendWelcomeEmail(to: string, name: string): Promise<void>;
}

// Implementaci√≥n SendGrid
@Injectable()
class SendGridAdapter implements IEmailAdapter {
  async sendWelcomeEmail(to: string, name: string): Promise<void> {
    await this.sendgridClient.send({
      to, from: 'noreply@nexus.com',
      templateId: 'welcome-template',
      dynamicTemplateData: { name }
    });
  }
}
```

#### Adaptadores Implementados

| Adaptador | Servicio Externo | Microservicios que lo usan |
|---|---|---|
| **SendGridAdapter** | SendGrid API | Perfil |
| **S3Adapter** | AWS S3 | Ideas, Colaboraci√≥n |
| **StripeAdapter** | Stripe API | Pagos |
| **ExpoPushAdapter** | Expo Push Notifications | Colaboraci√≥n |
| **ElasticsearchAdapter** | Elasticsearch | B√∫squeda |
| **RedisAdapter** | Redis Pub/Sub | Colaboraci√≥n |

---

### 4. Patr√≥n: Dependency Injection (DI)

#### Descripci√≥n

NestJS utiliza inyecci√≥n de dependencias para gestionar la creaci√≥n y ciclo de vida de componentes.

#### Implementaci√≥n

```typescript
@Injectable()
export class ChatService {
  constructor(
    private readonly messageRepo: MessageRepository,
    private readonly roomRepo: RoomRepository,
    private readonly redisAdapter: RedisAdapter,
    private readonly eventPublisher: EventPublisher
  ) {}
  
  async sendMessage(roomId: string, userId: string, content: string) {
    const message = await this.messageRepo.create({ roomId, userId, content });
    await this.redisAdapter.publish('message:new', message);
    await this.eventPublisher.publish('MessageSent', message);
    return message;
  }
}
```

#### Beneficios

- **Bajo Acoplamiento**: Componentes no crean sus dependencias
- **Testabilidad**: F√°cil inyectar mocks en tests
- **Configuraci√≥n Centralizada**: NestJS gestiona el ciclo de vida

---

### 5. Patr√≥n: DTO (Data Transfer Object)

#### Descripci√≥n

Objetos que transportan datos entre capas, con validaci√≥n autom√°tica.

#### Implementaci√≥n con Class-Validator

```typescript
export class CreateIdeaDto {
  @IsString()
  @MinLength(10)
  @MaxLength(100)
  title: string;

  @IsString()
  @MinLength(50)
  description: string;

  @IsEnum(IdeaCategory)
  category: IdeaCategory;

  @IsArray()
  @IsString({ each: true })
  tags: string[];
}
```

#### Beneficios

- **Validaci√≥n Autom√°tica**: NestJS valida DTOs con `ValidationPipe`
- **Documentaci√≥n**: DTOs documentan la estructura de datos
- **Type Safety**: TypeScript garantiza tipos correctos

---

### 6. Patr√≥n: CQRS (Command Query Responsibility Segregation)

#### Descripci√≥n

Separa operaciones de lectura (Queries) de operaciones de escritura (Commands). Aplicado parcialmente en el Microservicio de B√∫squeda.

#### Implementaci√≥n en MS B√∫squeda

![Implementaci√≥n en MS B√∫squeda](./diagrama/MS_BUSQUEDA.png)

**Escritura (Command)**:
- `IndexService` escucha eventos y actualiza Elasticsearch
- Optimizado para escritura r√°pida

**Lectura (Query)**:
- `SearchService` consulta Elasticsearch
- Optimizado para b√∫squedas complejas

#### Beneficios

- **Escalabilidad**: Escalar lectura y escritura independientemente
- **Optimizaci√≥n**: Modelos diferentes para lectura y escritura
- **Eventual Consistency**: Aceptable para b√∫squeda

---

### 7. Patr√≥n: Event-Driven Communication (Interna)

#### Descripci√≥n

Componentes se comunican mediante eventos internos y externos.

#### Eventos Internos vs Externos

![Eventos Internos vs Externos](./diagrama/EVENT-DRIVEN.png)

**Eventos Externos** (via RabbitMQ):
- `IdeaCreated`, `MessageSent`, `PaymentCompleted`
- Comunicaci√≥n entre microservicios

**Eventos Internos** (NestJS EventEmitter):
- Comunicaci√≥n dentro del mismo microservicio
- Ejemplo: `UserCreated` ‚Üí enviar email de bienvenida

---

### 8. Patr√≥n: Middleware y Guards (NestJS)

#### Descripci√≥n

Interceptan peticiones para validaci√≥n, autenticaci√≥n y logging.

#### Guards Implementados

```typescript
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }
}

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.get('roles', context.getHandler());
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some(role => user.roles.includes(role));
  }
}
```

**Uso en Controllers**:

```typescript
@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AdminController {
  @Get('users')
  @Roles('admin')
  async getUsers() { /* ... */ }
}
```

---

### 9. Patr√≥n: WebSocket Gateway (Socket.IO)

#### Descripci√≥n

Manejo de conexiones WebSocket para comunicaci√≥n en tiempo real.

#### Implementaci√≥n en MS Colaboraci√≥n

```typescript
@WebSocketGateway({ namespace: '/chat' })
export class ChatGateway {
  @WebSocketServer() server: Server;
  
  constructor(
    private chatService: ChatService,
    private redisAdapter: RedisAdapter
  ) {}
  
  @SubscribeMessage('message:send')
  async handleMessage(client: Socket, payload: SendMessageDto) {
    const message = await this.chatService.sendMessage(payload);
    this.server.to(payload.roomId).emit('message:receive', message);
  }
  
  @SubscribeMessage('user:typing')
  handleTyping(client: Socket, payload: { roomId: string }) {
    client.to(payload.roomId).emit('user:typing', { userId: client.data.userId });
  }
}
```

---

### Resumen de Patrones Aplicados

| Patr√≥n | Microservicios | Beneficio Principal |
|---|---|---|
| **Layered Architecture** | Todos | Separaci√≥n de responsabilidades |
| **Repository** | Perfil, Colaboraci√≥n, Pagos | Abstracci√≥n de persistencia |
| **Adapter** | Todos | Desacoplamiento de servicios externos |
| **Dependency Injection** | Todos | Testabilidad y bajo acoplamiento |
| **DTO** | Todos | Validaci√≥n autom√°tica |
| **CQRS** | B√∫squeda | Optimizaci√≥n lectura/escritura |
| **Event-Driven** | Todos | Comunicaci√≥n desacoplada |
| **Guards** | Todos | Autenticaci√≥n y autorizaci√≥n |
| **WebSocket Gateway** | Colaboraci√≥n | Comunicaci√≥n en tiempo real |

---

[‚¨ÖÔ∏è Anterior](../9.3.2/9.3.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../9.3.4/9.3.4.md)