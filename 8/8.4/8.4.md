> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.4. M√≥dulo 4 / Integrante 4](8.4.md)

# 8.4. M√≥dulo 4 / Integrante 4
## PATRONES DE M√ìDULO

**T√≠tulo**:  
Elecci√≥n entre Arquitectura en Capas vs Descomposici√≥n por Dominio para el M√≥dulo de Publicaci√≥n de Ideas

**Contexto**:  
El equipo de desarrollo necesita una estructura que facilite el mantenimiento, la extensibilidad y la clara separaci√≥n de responsabilidades. Actualmente se cuenta con MongoDB para persistencia flexible

**Alternativas**:  
1. **Arquitectura en Capas (Layered Architecture)**  
   - Organiza el c√≥digo en capas horizontales: Presentaci√≥n (Controladores REST), L√≥gica de Negocio (Servicios), Acceso a Datos (Repositorios), e Infraestructura (S3, RabbitMQ).
   - Cada capa solo puede comunicarse con la capa inmediatamente inferior.
   - Facilita la comprensi√≥n del flujo de datos y responsabilidades t√©cnicas.
   - Puede generar acoplamiento entre capas y dificultar cambios que atraviesan m√∫ltiples capas.

2. **Descomposici√≥n por Dominio (Domain-Driven Design)**  
   - Organiza el c√≥digo en m√≥dulos verticales basados en subdominios: "Ideas", "Proyectos", "Multimedia", "Eventos".
   - Cada m√≥dulo encapsula sus propias capas internas (controladores, servicios, repositorios).
   - Promueve alta cohesi√≥n dentro de cada dominio y bajo acoplamiento entre dominios.
   - Facilita la evoluci√≥n independiente de cada subdominio y mejora la mantenibilidad a largo plazo.

**Criterios de Elecci√≥n**:  
- Complejidad del dominio de negocio (gesti√≥n de ideas, proyectos, multimedia, eventos).
- Facilidad para extender funcionalidades futuras (nuevos tipos de ideas, categor√≠as, integraciones).
- Mantenibilidad y claridad para desarrolladores nuevos en el equipo.
- Alineaci√≥n con la arquitectura de microservicios ya implementada en NEXUS.

**Decisi√≥n**:  
Se elige **Descomposici√≥n por Dominio (Domain-Driven Design)**.

**Sustento**:  
El M√≥dulo de Publicaci√≥n de Ideas tiene subdominios claramente diferenciados con l√≥gica de negocio compleja. La descomposici√≥n por dominio permite que cada subdominio evolucione independientemente sin afectar a los dem√°s. Esto es crucial dado que NEXUS est√° en crecimiento y se anticipan nuevas funcionalidades, esta arquitectura se alinea con la filosof√≠a de microservicios ya adoptada en NEXUS, donde cada servicio encapsula un dominio de negocio completo. La estructura por capas tradicional dificultar√≠a la evoluci√≥n de features complejas que requieren cambios en m√∫ltiples capas simult√°neamente.

---

## PATRONES DE COMPONENTE Y CONECTOR

**T√≠tulo**:  
Elecci√≥n de patr√≥n de comunicaci√≥n entre componentes para el procesamiento de publicaci√≥n de ideas

**Contexto**:  
Cuando un usuario publica una idea, el sistema debe ejecutar m√∫ltiples operaciones: validar los datos, guardar en MongoDB, subir archivos multimedia a S3, generar thumbnails, indexaci√≥n en Elasticsearch, y enviar notificaciones. Estas operaciones tienen diferentes tiempos de ejecuci√≥n y niveles de criticidad. Se necesita un patr√≥n que permita procesar estas tareas de manera eficiente, con posibilidad de reintentos en caso de fallo, y que no bloquee la respuesta al usuario.

**Alternativas**:  
1. **Broker (Message Broker Pattern)**  
   - Los componentes se comunican a trav√©s de un intermediario (RabbitMQ).
   - Desacoplamiento total entre emisores y receptores de mensajes.
   - Permite procesamiento as√≠ncrono, reintentos autom√°ticos y balanceo de carga.
   - Mayor complejidad en el debugging y trazabilidad de flujos.

2. **Modelo-Vista-Controlador (MVC)**  
   - Separa la l√≥gica de presentaci√≥n (controladores REST) de la l√≥gica de negocio (servicios) y datos (repositorios).
   - Patr√≥n s√≠ncrono enfocado en la estructuraci√≥n del c√≥digo.
   - No maneja naturalmente operaciones as√≠ncronas o de larga duraci√≥n.

3. **Pipe-and-Filter**  
   - Procesa la publicaci√≥n de ideas como una secuencia de filtros: validaci√≥n ‚Üí persistencia ‚Üí multimedia ‚Üí eventos ‚Üí notificaciones.
   - Cada filtro transforma los datos y los pasa al siguiente.
   - Excelente para procesamiento secuencial, pero dificulta operaciones paralelas.

4. **Cliente-Servidor**  
   - El cliente (app m√≥vil) hace peticiones HTTP al servidor (microservicio).
   - Comunicaci√≥n s√≠ncrona request-response.
   - Simple pero no adecuado para operaciones de larga duraci√≥n.

**Criterios de Elecci√≥n**:  
- Necesidad de procesamiento as√≠ncrono para operaciones no cr√≠ticas (thumbnails, indexaci√≥n).
- Desacoplamiento entre componentes para facilitar escalabilidad independiente.
- Capacidad de reintentos y manejo de fallos transitorios.
- Experiencia de usuario (respuesta r√°pida sin esperar operaciones secundarias).

**Decisi√≥n**:  
Se elige **Broker (Message Broker Pattern)** con RabbitMQ.

**Sustento**:  
El patr√≥n Broker permite que la publicaci√≥n de ideas responda inmediatamente al usuario despu√©s de la persistencia cr√≠tica en MongoDB, mientras que las operaciones secundarias (procesamiento de multimedia, indexaci√≥n en Elasticsearch, notificaciones) se ejecutan de forma as√≠ncrona mediante mensajes en RabbitMQ. Esto mejora la experiencia del usuario al no bloquear la interfaz y permite que cada consumidor escale independientemente seg√∫n la carga.

---
**T√≠tulo**:  
Elecci√≥n de patr√≥n para la sincronizaci√≥n de ideas publicadas con el motor de b√∫squeda Elasticsearch

**Contexto**:  
Cada vez que se publica, edita o elimina una idea en el M√≥dulo de Publicaci√≥n, el √≠ndice de Elasticsearch debe actualizarse para reflejar los cambios en tiempo real. El Microservicio de Ideas no debe tener conocimiento directo del Microservicio de B√∫squeda ni de su implementaci√≥n interna. Adem√°s, en el futuro podr√≠an agregarse otros consumidores de estos eventos (notificaciones push, analytics, recomendaciones). Se necesita un mecanismo de sincronizaci√≥n que sea desacoplado, escalable y permita agregar nuevos consumidores sin modificar el publicador.

**Alternativas**:  
1. **Arquitectura Orientada a Servicios (SOA)**  
   - El Microservicio de Ideas llama directamente al API REST del Microservicio de B√∫squeda para sincronizar.
   - Acoplamiento fuerte entre servicios mediante contratos de API.
   - Dificulta agregar nuevos consumidores (requiere modificar el c√≥digo del publicador).
   - Manejo expl√≠cito de fallos y reintentos en cada llamada.

2. **Publicar-Suscribir (Pub/Sub)**  
   - El Microservicio de Ideas publica eventos ("IdeaCreated", "IdeaUpdated", "IdeaDeleted") en RabbitMQ.
   - El Microservicio de B√∫squeda se suscribe a estos eventos y actualiza Elasticsearch.
   - Desacoplamiento total: el publicador no conoce a los suscriptores.
   - Nuevos consumidores pueden suscribirse sin modificar el publicador.
   - Manejo autom√°tico de reintentos y escalabilidad mediante colas.

3. **Datos Compartidos (Shared Database)**  
   - Ambos microservicios acceden directamente a la base de datos MongoDB de ideas.
   - El Microservicio de B√∫squeda consulta peri√≥dicamente cambios o usa change streams de MongoDB.
   - Acoplamiento fuerte a nivel de datos, viola principios de microservicios.
   - Dificultad para migrar a diferentes tecnolog√≠as de persistencia.

**Criterios de Elecci√≥n**:  
- Desacoplamiento entre microservicios 
- Escalabilidad para m√∫ltiples consumidores de eventos 
- Confiabilidad en la sincronizaci√≥n con manejo de fallos transitorios.
- Alineaci√≥n con arquitectura event-driven de NEXUS.

**Decisi√≥n**:  
Se elige **Publicar-Suscribir (Pub/Sub)** mediante RabbitMQ.

**Sustento**:  
El patr√≥n Pub/Sub proporciona el desacoplamiento necesario para una arquitectura de microservicios saludable. El Microservicio de Ideas solo necesita publicar eventos de dominio cuando ocurren cambios, sin preocuparse por qui√©n los consumir√° ni c√≥mo. Esto permite que el Microservicio de B√∫squeda indexe en Elasticsearch de forma independiente y que en el futuro se agreguen nuevos consumidores sin modificar ni redesplegar el publicador

---

## PATRONES DE ASIGNACI√ìN

**T√≠tulo**:  
Elecci√≥n de patr√≥n de despliegue para el M√≥dulo de Publicaci√≥n de Ideas

**Contexto**:  
El M√≥dulo de Publicaci√≥n de Ideas debe desplegarse de manera que sea escalable, mantenible y permita separaci√≥n clara de responsabilidades. La aplicaci√≥n maneja peticiones HTTP desde el frontend React Native, procesa l√≥gica de negocio compleja, interact√∫a con MongoDB, S3 y RabbitMQ, y debe soportar picos de tr√°fico durante eventos promocionales. El equipo de operaciones tiene experiencia con contenedores Docker y orquestaci√≥n con Kubernetes. Se necesita decidir c√≥mo organizar f√≠sicamente los componentes del sistema.

**Alternativas**:  
1. **Map-Reduce**  
   - Divide el procesamiento de grandes vol√∫menes de datos en fases Map (procesamiento paralelo) y Reduce (agregaci√≥n).
   - Orientado a procesamiento batch de datos masivos (an√°lisis de logs, procesamiento de millones de ideas).
   - No es arquitectura de despliegue sino patr√≥n de procesamiento distribuido.
   - No aplica directamente para una aplicaci√≥n web transaccional en tiempo real.

2. **Multi-Tier (N-Tier Architecture)**  
   - Organiza la aplicaci√≥n en tiers f√≠sicos separados: Presentation Tier (API Gateway), Application Tier (Microservicio de Ideas), Data Tier (MongoDB, S3).
   - Cada tier se despliega en infraestructura independiente con escalabilidad horizontal.
   - Permite optimizar recursos seg√∫n las necesidades de cada tier (m√°s instancias de App Tier durante picos).
   - Facilita mantenimiento, actualizaciones y seguridad mediante segmentaci√≥n de red.
   - Se alinea con arquitectura de microservicios y pr√°cticas de DevOps.

**Criterios de Elecci√≥n**:  
- Escalabilidad independiente de cada componente del sistema.
- Seguridad mediante segmentaci√≥n de red
- Facilidad de despliegue y actualizaci√≥n mediante CI/CD.
- Optimizaci√≥n de recursos seg√∫n carga de cada componente.

**Decisi√≥n**:  
Se elige **Multi-Tier (N-Tier Architecture)**.

**Sustento**:  
La arquitectura Multi-Tier es la elecci√≥n natural para el despliegue del M√≥dulo de Publicaci√≥n de Ideas en NEXUS. Permite separar f√≠sicamente el API Gateway (expuesto p√∫blicamente), el Microservicio de Ideas (en red privada) y las bases de datos/storage (en red a√∫n m√°s restringida).Esta arquitectura es est√°ndar en la industria para aplicaciones web modernas y se integra perfectamente con Kubernetes para orquestaci√≥n de contenedores. Map-Reduce no aplica aqu√≠ porque NEXUS es una plataforma transaccional en tiempo real, no un sistema de procesamiento batch de grandes vol√∫menes de datos.

---

## PATRONES CLOUD

### **Tipo de Patr√≥n**: Selecci√≥n de Patrones Cloud para el M√≥dulo de Publicaci√≥n de Ideas

**T√≠tulo**:  
Elecci√≥n de patrones Cloud para garantizar confiabilidad, rendimiento y seguridad en la publicaci√≥n de ideas

**Contexto**:  
El M√≥dulo de Publicaci√≥n de Ideas es cr√≠tico para NEXUS y maneja operaciones que involucran m√∫ltiples servicios externos (S3, MongoDB, RabbitMQ, Elasticsearch). Se debe garantizar alta disponibilidad, manejo resiliente de fallos transitorios, protecci√≥n contra sobrecargas, y procesamiento eficiente de solicitudes as√≠ncronas. La plataforma crecer√° en usuarios y necesita patrones cloud que permitan escalabilidad autom√°tica, manejo de errores graceful y optimizaci√≥n de costos.

**Alternativas** (se seleccionar√°n m√∫ltiples patrones complementarios):

1. **Circuit Breaker**  
   - Previene que fallos en servicios externos (S3, MongoDB) propaguen fallos en cascada.
   - Cuando un servicio falla repetidamente, el circuit se "abre" y las peticiones fallan r√°pidamente sin intentar la operaci√≥n.
   - Despu√©s de un timeout, el circuit entra en modo "half-open" para probar si el servicio se recuper√≥.
   - Mejora la experiencia del usuario con respuestas r√°pidas en lugar de timeouts largos.

2. **Retry Pattern**  
   - Reintenta autom√°ticamente operaciones fallidas con backoff exponencial.
   - Maneja fallos transitorios comunes en sistemas distribuidos (timeouts de red, rate limits temporales).
   - Combinado con Circuit Breaker para evitar reintentos innecesarios cuando el servicio est√° definitivamente ca√≠do.

3. **Bulkhead Pattern**  
   - A√≠sla recursos (pools de conexiones, threads) para diferentes operaciones cr√≠ticas.
   - Si las operaciones de S3 fallan/saturan, no afectan las operaciones de MongoDB.
   - Previene que un componente lento o fallido consuma todos los recursos del sistema.

4. **Asynchronous Request-Reply**  
   - Desacopla operaciones de larga duraci√≥n (procesamiento de video, generaci√≥n de thumbnails) del request HTTP inicial.
   - El cliente recibe inmediatamente un ID de operaci√≥n y puede consultar el estado posteriormente.
   - Mejora la experiencia del usuario y permite que el backend procese trabajos pesados en background.

5. **Queue-Based Load Leveling**  
   - Usa colas (RabbitMQ) para absorber picos de tr√°fico en publicaciones de ideas.
   - Protege a MongoDB y S3 de sobrecarga mediante procesamiento controlado.
   - Permite escalar consumers independientemente seg√∫n la profundidad de la cola.

6. **Cache-Aside**  
   - Cachea ideas frecuentemente consultadas (trending ideas, categor√≠as populares).
   - Reduce la carga en MongoDB y mejora tiempos de respuesta.
   - El microservicio consulta cache primero, si no existe carga de DB y actualiza cache.

7. **Throttling Pattern**  
   - Limita el rate de publicaciones por usuario para prevenir abuso y spam.
   - Protege el sistema de sobrecarga mediante l√≠mites configurables (ej: 10 ideas/hora por usuario).
   - Responde con HTTP 429 (Too Many Requests) cuando se exceden l√≠mites.

8. **Health Endpoint Monitoring**  
   - Expone endpoint `/health` que reporta el estado del microservicio y sus dependencias.
   - Kubernetes usa este endpoint para health checks y decide reiniciar pods no saludables.
   - Permite monitoreo proactivo y alertas autom√°ticas.

**Criterios de Elecci√≥n**:  
- **Confiabilidad**: Manejo resiliente de fallos y prevenci√≥n de cascadas de errores.
- **Performance**: Respuestas r√°pidas al usuario mediante procesamiento as√≠ncrono y caching.
- **Seguridad**: Protecci√≥n contra abuso y sobrecarga mediante rate limiting.
- **Costo**: Optimizaci√≥n de uso de recursos mediante colas y bulkheads.
- **Operabilidad**: Monitoreo y observabilidad mediante health endpoints.

**Decisi√≥n**:  
Se implementar√°n los siguientes patrones de forma complementaria:
- **Circuit Breaker + Retry** para comunicaci√≥n con servicios externos
- **Queue-Based Load Leveling** para absorci√≥n de picos de tr√°fico

**Sustento**:  
La combinaci√≥n de estos patrones cloud proporciona una arquitectura robusta, resiliente y escalable para el M√≥dulo de Publicaci√≥n de Ideas. **Circuit Breaker + Retry** garantizan que fallos transitorios en S3 o MongoDB no afecten la disponibilidad general del sistema, **Queue-Based Load Leveling** protege contra picos de tr√°fico


[‚¨ÖÔ∏è Anterior](../8.3/8.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.5/8.5.md)