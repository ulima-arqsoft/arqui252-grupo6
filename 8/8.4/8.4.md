> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.4. M√≥dulo 4 / Integrante 4](8.4.md)

# 8.4. M√≥dulo 4 / Integrante 4
## PATRONES DE M√ìDULO
## Escenario 1: Rendimiento e Interoperabilidad

| Atributo | ID Escenario | Fuente Est√≠mulo | Est√≠mulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Rendimiento** | **ESC-06** | Usuario Final | Env√≠o masivo de solicitudes de ‚ÄúPublicar Idea‚Äù (pico de tr√°fico) | API Gateway / Broker | Carga Alta | El Gateway delega la solicitud a una cola y retorna control inmediato, desacoplando el procesamiento | Latencia de aceptaci√≥n \< 200 ms | El patr√≥n estructural permite manejar cargas as√≠ncronas sin bloquear el servidor web |

### Patr√≥n Elegido

El patr√≥n elegido es **Broker** implementado a trav√©s de RabbitMQ.

**T√≠tulo**:

  - Desacoplamiento de Servicios mediante Patr√≥n Broker (RabbitMQ).

**Contexto**:

  - El sistema Nexus est√° compuesto por m√∫ltiples servicios (`Ideas`, `Users`, `Payments`) que necesitan colaborar para publicar una idea (validar usuario, procesar pago, guardar idea). Si estos servicios se comunicaran punto a punto de forma s√≠ncrona, se generar√≠a un alto acoplamiento y latencia acumulada. Se requiere una estructura que distribuya las solicitudes sin que el cliente conozca la ubicaci√≥n o estado de los servicios finales.

**Alternativas**:

1.  **Patr√≥n Broker (Recomendado)**:
      - Introduce un componente intermediario (el *Broker*) que recibe, filtra y reenv√≠a las solicitudes a los servidores apropiados.
      - **Alineaci√≥n Te√≥rica**: "Encontrar la manera de estructurar soluciones distribuidas de forma que los usuarios del servicio no necesiten conocer la naturaleza y ubicaci√≥n de los proveedores".
2.  **Patr√≥n Cliente-Servidor Directo (REST/HTTP)**:
      - El API Gateway llama directamente por HTTP a `Ideas Service`.
      - **Contra**: Si `Ideas Service` est√° ca√≠do o lento, el Gateway se bloquea esperando respuesta, afectando el rendimiento (ESC-06).
3.  **Patr√≥n Pipe-and-Filter**:
      - Procesar la idea como una secuencia de transformaciones de datos.
      - **Contra**: Es m√°s adecuado para procesamiento de *streams* de datos secuenciales, no para transacciones de negocio distribuidas.

**Criterios de Elecci√≥n**:

  - Desacoplamiento temporal (el emisor no espera al receptor).
  - Escalabilidad de componentes individuales.
  - Tolerancia a la ubicaci√≥n f√≠sica de los servicios.

**Decisi√≥n**:

  - Se valida y mantiene el uso del **Patr√≥n Broker** implementado en la arquitectura actual mediante **RabbitMQ**.

**Sustento**:

  - El patr√≥n Broker permite desacoplar clientes de servidores, ideal para sistemas distribuidos 
-----

## Escenario 2: Testabilidad y Usabilidad (Frontend)

| Atributo | ID Escenario | Fuente Est√≠mulo | Est√≠mulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Testabilidad** | **ESC-09** | Equipo QA | QA necesita probar la l√≥gica de publicaci√≥n sin depender de la UI o el Backend real | C√≥digo M√≥vil (Frontend) | Entorno de Pruebas | La l√≥gica de negocio est√° aislada de la vista, permitiendo tests unitarios r√°pidos y mocks de datos | Cobertura de tests \> 80% en l√≥gica | Facilita el mantenimiento y cambios en la interfaz sin romper reglas de negocio |

### Patr√≥n Elegido

El patr√≥n elegido es **Modelo-Vista-Controlador (MVC)**
**T√≠tulo**:

  - Separaci√≥n de Responsabilidades mediante MVC (Hooks vs Componentes).

**Contexto**:

  - La aplicaci√≥n m√≥vil maneja flujos complejos: validaci√≥n de formularios, selecci√≥n de archivos y gesti√≥n de estados de carga. Mezclar esta l√≥gica con el c√≥digo de renderizado (JSX) hace que el c√≥digo sea dif√≠cil de probar (ESC-09) y dif√≠cil de modificar si se decide cambiar la librer√≠a de UI (ESC-02).

**Alternativas**:

1.  **Modelo-Vista-Controlador (MVC)**:
      - Separa la aplicaci√≥n en tres componentes: Modelo (Datos/Estado), Vista (Renderizado) y Controlador (L√≥gica/Gesti√≥n de eventos).
2.  **Monolithic View (Spaghetti Code)**:
      - Tener toda la l√≥gica `fetch`, validaciones y `return <View>` en un solo archivo gigante.
      - **Contra**: Imposible de testear unitariamente y muy dif√≠cil de mantener.
3.  **Modelo-Vista-Modelo de Vista (MVVM)**:
      - Variante moderna donde el "ViewModel" expone flujos de datos a la vista. Es muy similar a lo que hacen los *Hooks* de React.

**Criterios de Elecci√≥n**:

  - Facilidad para realizar pruebas unitarias (*Unit Testing*) de la l√≥gica.
  - Independencia de la tecnolog√≠a de interfaz gr√°fica.
  - Claridad en la lectura del c√≥digo.

**Decisi√≥n**:

  - Se adopta una variante del patr√≥n **MVC/MVVM** implementada mediante **Custom Hooks** (Controlador/ViewModel) y **Componentes Funcionales** (Vista).

**Sustento**:

  -  El patr√≥n busca dividir la aplicaci√≥n para que el controlador defina el comportamiento de la aplicaci√≥n y mapee acciones del usuario a actualizaciones del modelo

-----

## Escenario 3: Disponibilidad 

| Atributo | ID Escenario | Fuente Est√≠mulo | Est√≠mulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Disponibilidad** | **ESC-04** | Sistema Externo | Falla un servicio auxiliar (ej. Servicio de Pagos) | Arquitectura Backend | Fallo Parcial | El M√≥dulo de Ideas sigue funcionando para lectura y escritura, aislando el fallo del otro servicio | Uptime del m√≥dulo Ideas \> 99.9% | Evita la ca√≠da en cascada de toda la plataforma |

### Patr√≥n Elegido

El patr√≥n elegido es **Arquitectura Orientada a Servicios (SOA)**

**T√≠tulo**:

  - Aislamiento de Fallos mediante Arquitectura Orientada a Servicios (Microservicios).

**Contexto**:

  - Nexus integra dominios de negocio muy distintos: Gesti√≥n de Usuarios (seguridad cr√≠tica), Ideas (contenido flexible) y Pagos (transaccional estricto). Un fallo en el c√≥digo de Pagos no deber√≠a detener la capacidad de los usuarios para explorar o publicar ideas (ESC-04). El enfoque monol√≠tico tradicional ser√≠a un punto √∫nico de fallo.

**Alternativas**:

1.  **Arquitectura Orientada a Servicios (SOA / Microservicios)**:
      - Descompone la aplicaci√≥n en servicios independientes que interoperan. "Los clientes necesitan saber y utilizar estos servicios sin un conocimiento detallado de su implementaci√≥n".
      - **Pro**: Cada servicio tiene su propio ciclo de vida, base de datos y tolerancia a fallos.
2.  **Patr√≥n Multi-Tier (N-Capas) Monol√≠tico**:
      - Capas l√≥gicas (Web, Negocio, Datos) pero desplegadas en un solo servidor/artefacto.
      - **Contra**: Si la capa de negocio falla por un error de memoria en Pagos, se cae todo el servidor.
3.  **Datos Compartidos (Shared Database)**:
      - M√∫ltiples servicios accediendo a una √∫nica base de datos gigante.
      - **Contra**: La base de datos se convierte en el cuello de botella y punto √∫nico de fallo.

**Criterios de Elecci√≥n**:

  - Aislamiento de fallos (Fault Isolation).
  - Escalabilidad independiente (poder escalar solo el servicio de Ideas).
  - Libertad tecnol√≥gica (Persistencia Pol√≠glota).

**Decisi√≥n**:

  - Se implementa el patr√≥n **SOA (Microservicios)** con el patr√≥n complementario de **Database per Service**.

**Sustento**:

  - SOA permite soportar la interoperabilidad de sistemas heterog√©neos y distribuidos.

[‚¨ÖÔ∏è Anterior](../8.3/8.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.5/8.5.md)