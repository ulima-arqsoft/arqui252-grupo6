> [6. Documentaci√≥n de Arquitectura (Bosquejo)](../6.md) ‚Ä∫ [6.3. Diagrama de Componentes](6.3.md)

# 6.3. Diagrama de Componentes
### 1. Aplicaci√≥n M√≥vil (Frontend)

![Diagrama de componente](./diagram/App.svg)

Este diagrama ilustra la arquitectura interna de la aplicaci√≥n m√≥vil desarrollada en **React Native**. Su objetivo es mostrar c√≥mo se estructura el c√≥digo del lado del cliente para separar las responsabilidades de presentaci√≥n (UI), l√≥gica de negocio (Controladores/Hooks) y comunicaci√≥n con el backend (Servicios).

**Descripci√≥n de Elementos y Flujo:**

* **Capa de Vista (Presentational Components):** Aqu√≠ se encuentran los componentes visuales con los que interact√∫a el usuario, como `IdeasScreen` (para ver y crear ideas), `ChatScreen` (para mensajer√≠a) y `PaymentScreen` (para realizar pagos). Estos componentes son "tontos", es decir, solo se encargan de renderizar datos y capturar eventos del usuario, delegando la l√≥gica a los hooks.
* **Capa de Controlador (Hooks & Logic):** Los Custom Hooks, como `useNexusController` y `useChatWebSocket`, act√∫an como el cerebro de la aplicaci√≥n m√≥vil.
    * `useNexusController`: Gestiona el estado global de la aplicaci√≥n (ej. usuario autenticado, lista de ideas cargadas) y contiene la l√≥gica de negocio del frontend (ej. validaciones de formulario antes de enviar).
    * `useChatWebSocket`: Maneja la l√≥gica espec√≠fica de la conexi√≥n en tiempo real, como escuchar eventos de "nuevo mensaje" o "escribiendo".
* **Capa de Servicio (Infraestructura):** Estos son m√≥dulos utilitarios que abstraen la comunicaci√≥n con el mundo exterior.
    * `apiClient`: Una instancia de Axios configurada con la URL base del API Gateway y los interceptores para a√±adir el token de autenticaci√≥n (JWT) en cada petici√≥n.
    * `socketClient`: El cliente de `socket.io` que mantiene el canal bidireccional abierto con el servidor de mensajes.
    * `storageService`: Utiliza `Expo FileSystem` para manejar la carga y cach√© de archivos locales (im√°genes, documentos) antes de subirlos.

**Interacci√≥n:**
El usuario interact√∫a con una **Pantalla**, la cual invoca una funci√≥n del **Hook** (Controlador). El Hook procesa la acci√≥n y llama al **Cliente API** o **Socket**, que finalmente se comunica con el **API Gateway** o el servicio de mensajes externo.

---

### 2. API Gateway & Broker (Entrada)

![Diagrama de componente](./diagram/apiGateway.svg)

Este diagrama detalla el punto de entrada √∫nico al backend (**API Gateway**) y su integraci√≥n con el bus de mensajes (**RabbitMQ**). Muestra c√≥mo se manejan las peticiones entrantes, la seguridad y el enrutamiento as√≠ncrono hacia los microservicios.

**Descripci√≥n de Elementos y Flujo:**

* **Unified Controller (Gateway Controller):** Es el controlador principal en NestJS que expone los endpoints REST p√∫blicos (ej. `POST /ideas`, `POST /payments`). Su funci√≥n no es procesar el negocio, sino recibir la petici√≥n HTTP, validar su formato (DTOs) y delegarla.
* **Auth Guard (Middleware):** Un componente de seguridad crucial que intercepta cada petici√≥n antes de que llegue al controlador. Verifica la validez del token JWT contra **Supabase Auth** para asegurar que el usuario es quien dice ser y tiene permisos para realizar la acci√≥n.
* **RabbitMQ Proxy (ClientProxy):** Un m√≥dulo de NestJS configurado para actuar como "Productor" de mensajes AMQP.
* **RabbitMQ Broker:** El sistema de colas externo. Recibe los mensajes del Gateway y los distribuye a las colas espec√≠ficas (`users`, `ideas`, `messages`, `payments`) bas√°ndose en patrones de enrutamiento.

**Interacci√≥n:**
Una petici√≥n HTTP llega al **Gateway**. El **Auth Guard** la valida. Si es v√°lida, el **Controlador** toma los datos y usa el **RabbitMQ Proxy** para publicar un mensaje (evento o comando) en el **Broker**. El Gateway responde inmediatamente al cliente (ACK), liberando la conexi√≥n mientras el proceso contin√∫a en segundo plano.

---

### 3. Microservicio de Usuarios

![Diagrama de componente](./diagram/userService.svg)
Este diagrama explica c√≥mo se gestiona la identidad y el perfil de los usuarios, destacando la delegaci√≥n de la autenticaci√≥n a un servicio externo (**Supabase**) y la persistencia de datos adicionales en una base de datos relacional.

**Descripci√≥n de Elementos y Flujo:**

* **Users Consumer:** El punto de entrada del microservicio. No recibe HTTP, sino que escucha eventos de RabbitMQ (ej. `get_user_profile`, `update_user`).
* **Auth Service:** Contiene la l√≥gica de negocio relacionada con usuarios. Coordina la creaci√≥n de cuentas y la gesti√≥n de sesiones.
* **Supabase Client:** Un SDK que conecta con la API administrativa de Supabase. Se usa para operaciones cr√≠ticas de identidad que no se pueden hacer directamente en la BD local.
* **Users Repository:** Utiliza un ORM (como TypeORM o Prisma) para interactuar con la base de datos **PostgreSQL**. Aqu√≠ se guardan los datos del perfil extendido que Supabase no maneja (ej. nivel de experiencia, biograf√≠a detallada, roles espec√≠ficos de Nexus).

**Interacci√≥n:**
Cuando llega un mensaje para crear un usuario, el **Consumer** invoca al **Auth Service**. Este servicio puede consultar a **Supabase** para verificar datos de registro y luego usa el **Repository** para guardar el perfil en **PostgreSQL**.

---

### 4. Microservicio de Ideas

![Diagrama de componente](./diagram/IdeasService.svg)
Este es el diagrama del n√∫cleo de negocio de la plataforma. Muestra c√≥mo se crean, validan y almacenan las ideas, y c√≥mo se integran con capacidades de b√∫squeda avanzada (**Elasticsearch**).

**Descripci√≥n de Elementos y Flujo:**

* **Ideas Consumer:** Escucha eventos como `create_idea` o `update_idea` desde la cola de RabbitMQ.
* **Ideas Logic (Provider):** El coraz√≥n de la l√≥gica de negocio. Aplica reglas como: "¬øEl usuario tiene l√≠mite de ideas?", "Validar formato de presupuesto", "Cambiar estado de borrador a publicado".
* **Search Sync (Service):** Un componente especializado encargado de mantener la consistencia entre la base de datos principal y el motor de b√∫squeda. Cada vez que una idea cambia, este servicio actualiza el √≠ndice en **Elasticsearch**.
* **Ideas Repo:** Abstracci√≥n de Mongoose para interactuar con **MongoDB**. MongoDB se elige por su flexibilidad para guardar la estructura variada de una idea (t√≠tulo, descripci√≥n, arrays de tags, objetos de archivos adjuntos).

**Interacci√≥n:**
El **Consumer** recibe la orden de crear una idea. **Ideas Logic** la valida y llama a **Ideas Repo** para guardarla en **MongoDB**. Paralelamente (o tras el guardado exitoso), invoca a **Search Sync** para indexar la idea en **Elasticsearch**, permitiendo que sea buscable casi en tiempo real.

---

### 5. Microservicio de Mensajes

![Diagrama de componente](./diagram/messagesService.svg)
Ilustra la arquitectura h√≠brida necesaria para un chat: comunicaci√≥n en tiempo real para la experiencia de usuario y persistencia as√≠ncrona para el historial.

**Descripci√≥n de Elementos y Flujo:**

* **Socket Gateway:** A diferencia de los otros servicios, este componente expone un puerto **WebSocket** (usando Socket.io) para mantener conexiones persistentes con las Apps M√≥viles. Gestiona eventos como `join_room` (unirse a un chat) y `send_message`.
* **Message Consumer:** Escucha eventos del sistema (ej. "Notificar usuario offline") desde RabbitMQ.
* **Chat Service (Logic):** Gestiona la l√≥gica de las salas de chat, permisos (¬øqui√©n puede hablar con qui√©n?) y orquesta el flujo del mensaje.
* **Chat Repo:** Guarda el historial de mensajes en **MongoDB**. Se usa Mongo aqu√≠ por su alta velocidad de escritura y capacidad de almacenar grandes vol√∫menes de logs de chat.

**Interacci√≥n:**
Un usuario env√≠a un mensaje v√≠a WebSocket al **Socket Gateway**. Este lo pasa al **Chat Service**, que hace dos cosas: 1) Retransmite el mensaje inmediatamente a los otros usuarios conectados en la sala (tiempo real), y 2) Llama al **Chat Repo** para guardar el mensaje en la base de datos para el futuro.

---

### 6. Microservicio de Pagos

![Diagrama de componente](./diagram/paymentsService.svg)
Detalla el manejo seguro de transacciones financieras, el c√°lculo de comisiones de la plataforma y la integraci√≥n con la pasarela de pagos externa (**Stripe**).

**Descripci√≥n de Elementos y Flujo:**

* **Payment Consumer:** Escucha comandos de pago (`process_payment`) iniciados por el usuario o el sistema.
* **Payment Logic (Provider):** Contiene las reglas financieras cr√≠ticas: c√°lculo de comisiones de la plataforma (ej. 10%), validaci√≥n de montos y estados de la transacci√≥n.
* **Stripe Adapter:** Un "wrapper" o envoltorio alrededor del SDK de Stripe. Su funci√≥n es aislar la l√≥gica de negocio de la implementaci√≥n espec√≠fica de Stripe, facilitando cambios futuros o pruebas (mocking).
* **Transaction Repo:** Guarda un registro inmutable (Ledger) de todas las transacciones, intentos y resultados en una base de datos relacional (**PostgreSQL**) para garantizar integridad ACID.

**Interacci√≥n:**
Al recibir una solicitud de pago, **Payment Logic** calcula los montos finales y usa el **Stripe Adapter** para crear un "Payment Intent" en la API de **Stripe**. Una vez que Stripe responde (o v√≠a Webhook), el resultado se registra permanentemente en **PostgreSQL** mediante el **Transaction Repo**.

---

[‚¨ÖÔ∏è Anterior](../6.2/6.2.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../6.4/6.4.md)
