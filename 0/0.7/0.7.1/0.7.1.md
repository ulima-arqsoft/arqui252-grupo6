> [0. Acerca del Grupo](../../0.md) â€º [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) â€º [0.7.1. Integrante 1](0.7.1.md)

# 0.7.1. Integrante 1

# Event Sourcing
## PatrÃ³n de Arquitectura Cloud

---

## 1. Desarrollo Conceptual

### 1.1 Â¿QuÃ© es Event Sourcing?

Event Sourcing es un patrÃ³n arquitectÃ³nico donde los cambios de estado de una aplicaciÃ³n se almacenan como una secuencia inmutable de eventos, en lugar de persistir solo el estado actual. Cada cambio en el sistema se captura como un evento que describe quÃ© ocurriÃ³, cuÃ¡ndo ocurriÃ³ y quÃ© datos estaban involucrados.

**CaracterÃ­sticas principales:**
- Los eventos son la Ãºnica fuente de verdad (source of truth)
- Los eventos son inmutables - nunca se modifican o eliminan
- El estado actual se reconstruye reproduciendo todos los eventos
- Proporciona un historial completo y auditable de todos los cambios
- Permite viajar en el tiempo para ver estados pasados del sistema

### 1.2 Concepto Fundamental: El Evento

Un **evento** es un hecho que ocurriÃ³ en el pasado y que tiene relevancia para el negocio. Los eventos son:

**Inmutables:** Una vez que un evento ha ocurrido, no puede cambiar. Si se cometiÃ³ un error, se crea un nuevo evento compensatorio.

**Nombrados en pasado:** Reflejan algo que ya sucediÃ³:
- âœ… `CuentaCreada`, `DepositoRealizado`, `PedidoEnviado`
- âŒ `CrearCuenta`, `RealizarDeposito`, `EnviarPedido`

**Autocontenidos:** Contienen toda la informaciÃ³n necesaria para entender quÃ© pasÃ³:
```json
{
  "eventId": "evt_12345",
  "eventType": "PedidoCreado",
  "timestamp": "2025-01-15T10:30:00Z",
  "aggregateId": "order_789",
  "version": 1,
  "data": {
    "clienteId": "client_456",
    "items": [
      {"productoId": "prod_1", "cantidad": 2, "precio": 29.99}
    ],
    "total": 59.98,
    "direccionEnvio": "Av. Principal 123"
  }
}
```

### 1.3 Diferencia con Arquitecturas Tradicionales

#### Arquitectura CRUD Tradicional (State-Based)

```
Estado Actual en Base de Datos:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cuenta ID: 12345         â”‚
â”‚ Saldo: $500              â”‚
â”‚ Ãšltima ModificaciÃ³n: ... â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problemas:**
- âŒ Se pierde el historial de cÃ³mo llegamos al estado actual
- âŒ No sabemos quiÃ©n hizo quÃ© cambios ni cuÃ¡ndo
- âŒ Imposible auditar o deshacer operaciones
- âŒ DifÃ­cil reproducir bugs del pasado
- âŒ No hay trazabilidad completa

#### Event Sourcing (Event-Based)

```
Event Store (Secuencia de Eventos):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. CuentaCreada                    â”‚
â”‚    - ID: 12345                     â”‚
â”‚    - Titular: Juan PÃ©rez           â”‚
â”‚    - Fecha: 2025-01-01             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. DepositoRealizado               â”‚
â”‚    - Monto: $1000                  â”‚
â”‚    - Fecha: 2025-01-05             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. RetiroRealizado                 â”‚
â”‚    - Monto: $500                   â”‚
â”‚    - Fecha: 2025-01-10             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Estado Actual (Reconstruido):
Saldo = 0 + 1000 - 500 = $500
```

**Ventajas:**
- âœ… Historial completo y auditable
- âœ… Trazabilidad total de cambios
- âœ… Capacidad de reconstruir cualquier estado pasado
- âœ… Debugging facilitado
- âœ… Cumplimiento regulatorio automÃ¡tico

### 1.4 Componentes Principales

#### 1.4.1 Event Store

El **Event Store** es la base de datos especializada que almacena todos los eventos. CaracterÃ­sticas:

- **Append-only:** Solo se agregan eventos, nunca se modifican
- **Ordenamiento:** Los eventos se mantienen en orden cronolÃ³gico
- **Particionamiento:** Generalmente por Aggregate ID
- **OptimizaciÃ³n:** DiseÃ±ado para escrituras secuenciales rÃ¡pidas

**Estructura tÃ­pica:**
```
Event Stream por Aggregate:
account_12345/
  â”œâ”€ version 1: CuentaCreada
  â”œâ”€ version 2: DepositoRealizado
  â”œâ”€ version 3: RetiroRealizado
  â””â”€ version 4: TransferenciaEnviada
```

#### 1.4.2 Aggregate

Un **Aggregate** es una entidad o grupo de entidades que se trata como una unidad para cambios de datos. En Event Sourcing:

- Tiene un identificador Ãºnico (Aggregate ID)
- Todos los eventos relacionados se almacenan juntos
- Mantiene consistencia transaccional dentro del aggregate
- Es el boundary para la consistencia

**Ejemplo:**
```
Aggregate: Cuenta Bancaria (ID: acc_12345)
â”œâ”€ Invariante: Saldo no puede ser negativo
â”œâ”€ Comandos: Depositar, Retirar, Transferir
â””â”€ Eventos: CuentaCreada, DepositoRealizado, RetiroRealizado
```

#### 1.4.3 Proyecciones (Read Models)

Las **Proyecciones** son vistas materializadas del estado actual, optimizadas para consultas especÃ­ficas:

```
Event Stream          â†’    ProyecciÃ³n (Read Model)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CuentaCreada         â†’     tabla_cuentas
DepositoRealizado    â†’     â””â”€ id, titular, saldo_actual
RetiroRealizado      â†’     
                           tabla_transacciones
                           â””â”€ id, tipo, monto, fecha
                           
                           vista_cuentas_activas
                           â””â”€ solo cuentas con saldo > 0
```

**Ventajas de las proyecciones:**
- Optimizadas para consultas especÃ­ficas
- Pueden reconstruirse desde cero si se corrompen
- MÃºltiples proyecciones del mismo stream de eventos
- SeparaciÃ³n completa entre escritura (eventos) y lectura (proyecciones)

#### 1.4.4 Command Handler

El **Command Handler** procesa comandos del usuario y genera eventos:

```
Flujo de Comando a Evento:

Usuario â†’ Comando: "RealizarDeposito"
              â†“
       Command Handler
         â€¢ Valida reglas de negocio
         â€¢ Carga estado actual desde eventos
         â€¢ Verifica invariantes
              â†“
       Genera Evento: "DepositoRealizado"
              â†“
       Persiste en Event Store
              â†“
       Actualiza Proyecciones
```

#### 1.4.5 Event Handler / Projector

El **Event Handler** reacciona a eventos y actualiza proyecciones o dispara otros procesos:

```
Evento: DepositoRealizado
         â†“
    Event Handlers:
    â”œâ”€ Actualizar saldo en proyecciÃ³n
    â”œâ”€ Enviar notificaciÃ³n al cliente
    â”œâ”€ Registrar en sistema de auditorÃ­a
    â””â”€ Actualizar analytics en tiempo real
```

### 1.5 Patrones Relacionados

#### 1.5.1 CQRS (Command Query Responsibility Segregation)

Event Sourcing se combina frecuentemente con CQRS:

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Cliente   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
       â”‚               â”‚
  Commands          Queries
       â”‚               â”‚
       â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Write Model â”‚  â”‚Read Modelâ”‚
â”‚ (Events)    â”‚  â”‚(Projection)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Write Model:**
- Procesa comandos
- Valida reglas de negocio
- Genera eventos
- Optimizado para escritura

**Read Model:**
- Responde queries
- MÃºltiples proyecciones
- Denormalizado
- Optimizado para lectura

#### 1.5.2 Saga Pattern

Para transacciones distribuidas de larga duraciÃ³n:

```
Proceso: Reservar Vuelo + Hotel + Auto

Evento 1: VueloReservado
    â†“
Evento 2: HotelReservado
    â†“
Evento 3: AutoReservadoFallido  â† Error!
    â†“
CompensaciÃ³n:
    â† HotelCancelado
    â† VueloCancelado
```

#### 1.5.3 Event Streaming

Procesamiento de eventos en tiempo real:

```
Event Store â†’ Event Bus â†’ Consumidores
                â”œâ”€ Analytics
                â”œâ”€ Notificaciones
                â”œâ”€ ReplicaciÃ³n
                â””â”€ Machine Learning
```

### 1.6 Ventajas del Event Sourcing

#### 1.6.1 Auditabilidad Completa

**Trazabilidad total:** Cada cambio queda registrado permanentemente:
- QuiÃ©n hizo el cambio
- QuÃ© cambiÃ³ exactamente
- CuÃ¡ndo ocurriÃ³
- Por quÃ© ocurriÃ³ (si se incluye en el evento)

**Casos de uso:**
- Cumplimiento regulatorio (GDPR, SOX, HIPAA)
- AuditorÃ­as financieras
- InvestigaciÃ³n de fraudes
- AnÃ¡lisis forense de seguridad

#### 1.6.2 Temporal Queries (Viaje en el Tiempo)

Capacidad de ver el estado del sistema en cualquier momento del pasado:

```sql
-- Â¿CuÃ¡l era el saldo de esta cuenta el 1 de enero?
SELECT reconstruct_state('account_123', '2025-01-01')

-- Â¿CuÃ¡ntos pedidos pendientes habÃ­a la semana pasada?
SELECT count(*) FROM orders_projection 
AS OF '2025-01-08'
```

**Aplicaciones:**
- Debugging de producciÃ³n
- AnÃ¡lisis de tendencias histÃ³ricas
- ReproducciÃ³n de bugs
- Testing con datos reales del pasado

#### 1.6.3 Event Replay (ReproducciÃ³n de Eventos)

Capacidad de reconstruir proyecciones desde cero:

```
Escenario: Bug en proyecciÃ³n o nueva proyecciÃ³n necesaria

1. Eliminar proyecciÃ³n corrupta/antigua
2. Crear nueva proyecciÃ³n vacÃ­a
3. Replay todos los eventos
4. ProyecciÃ³n reconstruida correctamente
```

**Beneficios:**
- RecuperaciÃ³n de errores sin pÃ©rdida de datos
- MigraciÃ³n de esquemas simplificada
- Nuevas vistas de datos sin migraciÃ³n
- Testing contra datos histÃ³ricos reales

#### 1.6.4 Escalabilidad de Lectura

SeparaciÃ³n completa entre escritura y lectura (CQRS):

```
Escritura (Event Store):
  â””â”€ 1 instancia optimizada para append

Lectura (Proyecciones):
  â”œâ”€ ProyecciÃ³n 1: PostgreSQL (transaccional)
  â”œâ”€ ProyecciÃ³n 2: Elasticsearch (bÃºsqueda)
  â”œâ”€ ProyecciÃ³n 3: Redis (cache)
  â””â”€ ProyecciÃ³n 4: Cassandra (analytics)
```

#### 1.6.5 Event-Driven Architecture

Base natural para arquitecturas event-driven:

```
Event Store â†’ Message Broker â†’ Microservicios
                  â”œâ”€ Servicio de Notificaciones
                  â”œâ”€ Servicio de Analytics
                  â”œâ”€ Servicio de Reporting
                  â””â”€ Servicios de terceros
```

### 1.7 DesafÃ­os y Consideraciones

#### 1.7.1 Complejidad Aumentada

**Curva de aprendizaje:**
- Cambio de mentalidad de CRUD a eventos
- Manejo de consistencia eventual
- DiseÃ±o de eventos y agregados correctos
- Debugging mÃ¡s complejo

**Overhead operacional:**
- MÃ¡s componentes que mantener (Event Store, Projectors, Message Brokers)
- Monitoreo de proyecciones desfasadas
- GestiÃ³n de versiones de eventos

#### 1.7.2 Consistencia Eventual

Las proyecciones no se actualizan instantÃ¡neamente:

```
T0: Comando ejecutado, evento persistido
T1: Evento publicado al bus (+ algunos ms)
T2: ProyecciÃ³n actualizada (+ algunos ms)

Usuario escribe â†’ lee inmediatamente
    â†“
Puede leer estado desactualizado (stale read)
```

**Soluciones:**
- Propagar ID de evento al cliente
- Cliente espera hasta que proyecciÃ³n estÃ© actualizada
- Mostrar feedback optimista en UI
- DiseÃ±ar UX que tolere eventual consistency

#### 1.7.3 EvoluciÃ³n de Eventos (Schema Evolution)

Los eventos son inmutables, pero los esquemas cambian:

**Problema:**
```
Evento antiguo (v1):
{
  "eventType": "ClienteRegistrado",
  "data": {
    "nombre": "Juan PÃ©rez"  // Nombre completo en un campo
  }
}

Evento nuevo (v2):
{
  "eventType": "ClienteRegistrado",
  "data": {
    "nombre": "Juan",       // Separado en dos campos
    "apellido": "PÃ©rez"
  }
}
```

**Estrategias:**
1. **Upcasting:** Convertir eventos antiguos al formato nuevo al leerlos
2. **Versioning:** Mantener mÃºltiples versiones del handler
3. **Schema por defecto:** Valores por defecto para campos faltantes
4. **Event Transformation:** Proceso batch para actualizar eventos

#### 1.7.4 EliminaciÃ³n de Datos (GDPR)

El "derecho al olvido" conflicta con eventos inmutables:

**Estrategias de cumplimiento:**

1. **EncriptaciÃ³n de datos personales:**
```json
{
  "eventType": "ClienteRegistrado",
  "data": {
    "clienteId": "client_123",
    "datosPersonales": "encrypted_blob",  // Encriptado
    "keyId": "key_789"
  }
}
```
Al eliminar la clave de encriptaciÃ³n, los datos se vuelven irrecuperables.

2. **Eventos de compensaciÃ³n:**
```json
{
  "eventType": "DatosPersonalesEliminados",
  "data": {
    "clienteId": "client_123",
    "razon": "GDPR_request",
    "camposEliminados": ["nombre", "email", "direccion"]
  }
}
```

3. **Proyections con TTL:** Las proyecciones expiran y se eliminan automÃ¡ticamente.

#### 1.7.5 TamaÃ±o del Event Store

Los eventos crecen indefinidamente:

**Problema:**
```
Aggregate con 1M de eventos
  â†“
Reconstruir estado = procesar 1M eventos
  â†“
Lento e ineficiente
```

**Soluciones:**

1. **Snapshots:** Guardar estado en puntos especÃ­ficos
```
Events: 1, 2, 3, ..., 999
Snapshot en evento 1000: {estado_completo}
Events: 1001, 1002, ...

Reconstruir estado:
  1. Cargar snapshot en 1000
  2. Aplicar eventos 1001+
```

2. **Archivado:** Mover eventos antiguos a storage mÃ¡s barato
```
Hot storage (Ãºltimos 90 dÃ­as): SSD rÃ¡pido
Warm storage (1-2 aÃ±os): HDD
Cold storage (2+ aÃ±os): S3 Glacier
```

3. **Event Compaction:** Consolidar eventos redundantes
```
Antes:
  ProductoAgregado qty=1
  ProductoAgregado qty=1
  ProductoAgregado qty=1

DespuÃ©s:
  ProductoAgregado qty=3
```

### 1.8 Casos de Uso Ideales

#### 1.8.1 Sistemas Financieros

**Requisitos:**
- Auditabilidad total
- Trazabilidad de transacciones
- Cumplimiento regulatorio
- ReconciliaciÃ³n

**Ejemplos:**
- Banca online
- Procesamiento de pagos
- Trading platforms
- Contabilidad empresarial

#### 1.8.2 E-commerce

**Requisitos:**
- Historial de pedidos completo
- Estado de inventario preciso
- AnÃ¡lisis de comportamiento del usuario
- RecuperaciÃ³n ante fallos

**Eventos tÃ­picos:**
- CarritoCreado
- ProductoAgregado
- PedidoConfirmado
- PagoRealizado
- PedidoEnviado
- PedidoEntregado

#### 1.8.3 IoT y TelemetrÃ­a

**Requisitos:**
- Millones de eventos por segundo
- AnÃ¡lisis de series temporales
- DetecciÃ³n de anomalÃ­as
- Replay para entrenar ML

**Ejemplos:**
- Sensores industriales
- Dispositivos wearables
- Smart homes
- VehÃ­culos conectados

#### 1.8.4 Sistemas de GestiÃ³n de Workflows

**Requisitos:**
- Trazabilidad de procesos
- AuditorÃ­a de aprobaciones
- ReproducciÃ³n de flujos
- AnÃ¡lisis de cuellos de botella

**Ejemplos:**
- Sistemas de aprobaciÃ³n de crÃ©ditos
- GestiÃ³n de reclamos de seguros
- Procesos de RR.HH.
- Workflows hospitalarios

### 1.9 CuÃ¡ndo NO Usar Event Sourcing

âŒ **Sistemas CRUD simples sin requisitos de auditorÃ­a**
- Blog personal
- Directorio de contactos
- Sistema de gestiÃ³n de tareas bÃ¡sico

âŒ **Aplicaciones con datos altamente volÃ¡tiles que no requieren historial**
- CachÃ© de sesiones
- Datos temporales
- Contadores simples

âŒ **Cuando el equipo no tiene experiencia y el proyecto tiene presiÃ³n de tiempo**
- La curva de aprendizaje es significativa
- Puede ralentizar desarrollo inicial

âŒ **Sistemas con consultas complejas ad-hoc frecuentes**
- Business Intelligence con queries impredecibles
- Data warehouses con agregaciones complejas

---

## 2. Consideraciones TÃ©cnicas

### 2.1 TecnologÃ­as y Herramientas

#### 2.1.1 Event Stores Especializados

**EventStoreDB**
- PropÃ³sito especÃ­fico para Event Sourcing
- Proyecciones nativas
- Subscripciones a streams
- Clustering y alta disponibilidad

```javascript
// Ejemplo con EventStoreDB
const client = EventStoreDBClient.connectionString(
  "esdb://localhost:2113?tls=false"
);

// Append evento
await client.appendToStream("account-123", [
  jsonEvent({
    type: "DepositoRealizado",
    data: {
      monto: 1000,
      fecha: new Date()
    }
  })
]);

// Leer stream
const events = client.readStream("account-123");
for await (const event of events) {
  console.log(event);
}
```

**Apache Kafka**
- Event streaming platform
- Alto throughput (millones de eventos/seg)
- RetenciÃ³n configurable
- Ecosistema maduro (Kafka Streams, ksqlDB)

**AWS EventBridge / Azure Event Grid**
- Serverless event bus
- IntegraciÃ³n nativa con servicios cloud
- Escalamiento automÃ¡tico
- Pay-per-use

#### 2.1.2 Bases de Datos Tradicionales como Event Store

**PostgreSQL**
```sql
CREATE TABLE events (
  event_id UUID PRIMARY KEY,
  aggregate_id VARCHAR(255) NOT NULL,
  aggregate_type VARCHAR(100) NOT NULL,
  event_type VARCHAR(100) NOT NULL,
  event_version INT NOT NULL,
  event_data JSONB NOT NULL,
  metadata JSONB,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_version UNIQUE (aggregate_id, event_version)
);

CREATE INDEX idx_aggregate ON events(aggregate_id, event_version);
CREATE INDEX idx_timestamp ON events(timestamp);
```

**Ventajas:**
- Familiaridad del equipo
- Tooling existente
- ACID compliant
- Queries SQL estÃ¡ndar

**Desventajas:**
- No optimizado especÃ­ficamente para Event Sourcing
- Requiere Ã­ndices cuidadosos para performance
- Proyecciones manuales

#### 2.1.3 Frameworks y LibrerÃ­as

**Axon Framework (Java)**
```java
@Aggregate
public class CuentaBancaria {
    @AggregateIdentifier
    private String cuentaId;
    private BigDecimal saldo;

    @CommandHandler
    public CuentaBancaria(CrearCuentaCommand cmd) {
        apply(new CuentaCreadaEvent(cmd.getCuentaId(), cmd.getTitular()));
    }

    @EventSourcingHandler
    public void on(CuentaCreadaEvent event) {
        this.cuentaId = event.getCuentaId();
        this.saldo = BigDecimal.ZERO;
    }

    @CommandHandler
    public void handle(RealizarDepositoCommand cmd) {
        if (cmd.getMonto().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Monto debe ser positivo");
        }
        apply(new DepositoRealizadoEvent(cuentaId, cmd.getMonto()));
    }

    @EventSourcingHandler
    public void on(DepositoRealizadoEvent event) {
        this.saldo = this.saldo.add(event.getMonto());
    }
}
```

**Eventuous (.NET)**
**Marten (.NET)** - Event Store sobre PostgreSQL
**EventSauce (PHP)**
**Prooph (PHP)**

### 2.2 ImplementaciÃ³n de Ejemplo

#### 2.2.1 Arquitectura del Sistema Demo

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Cliente   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Gateway     â”‚
â”‚   (Express.js)    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â”‚       â”‚
Commands  Queries
   â”‚       â”‚
   â–¼       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Command â”‚ â”‚  Query   â”‚
â”‚Handler â”‚ â”‚  Handler â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â”‚           â”‚
    â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Event  â”‚ â”‚   Read   â”‚
â”‚  Store  â”‚ â”‚  Model   â”‚
â”‚(Postgre)â”‚ â”‚(Postgre) â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Event Busâ”‚
â”‚ (Redis) â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Projectorâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


---

[ğŸ  Home](../../../README.md) | [Siguiente â¡ï¸](../0.7.2/0.7.2.md)