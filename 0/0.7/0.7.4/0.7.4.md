> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) ‚Ä∫ [0.7.4. Integrante 4](0.7.4.md)

# 0.7.4. Integrante 4

# Index Table Pattern

## Problema
En muchas bases de datos NoSQL solo puedes buscar datos r√°pidamente si conoces la clave primaria. Consultar por otros campos requiere escanear todos los registros, lo cual es muy lento.

## Soluci√≥n
Crear manualmente Index Tables que organicen los datos por claves secundarias. 
Existen **3 estrategias**:

### 1. **Duplicaci√≥n Completa**
- Copia todos los datos en cada Index Table, organizados por diferentes claves
- **Ventaja**: Consulta r√°pida con una sola b√∫squeda
- **Desventaja**: Alto consumo de espacio y mantenimiento costoso

### 2. **Normalizaci√≥n Completa**
- La Index Table solo guarda la clave secundaria y una referencia a la clave primaria
- **Ventaja**: Ahorra espacio
- **Desventaja**: Requiere dos consultas (primero el √≠ndice, luego la tabla principal)

### 3. **Normalizaci√≥n Parcial** (recomendada)
- Duplica solo los campos consultados frecuentemente
- Mantiene referencias para campos menos usados
- **Equilibrio** entre velocidad y espacio

## Caracter√≠sticas Avanzadas

- **Claves compuestas**: Concatenar m√∫ltiples campos (ej: Ciudad+Apellido)
- **Datos fragmentados**: √ötil cuando la clave primaria est√° hasheada, evita recalcular hashes

## Cu√°ndo Usar

**S√ç usar cuando:**
- Se consulta frecuentemente por campos que no son la clave primaria
- Los datos son relativamente est√°ticos

**NO usar cuando:**
- Datos muy vol√°tiles (el √≠ndice queda obsoleto r√°pidamente)
- Campos con pocos valores distintos (ej: g√©nero)
- Distribuci√≥n muy sesgada (90% de registros con el mismo valor)

# DEMO Index Table

Comparacion de la mejora en tiempo por usar Index Table Pattern

### Previsualizacion de Datos extraidos de una base de datos NOSQL
![json data](./images/json.png)
### Creacion del Index
- Lee todas las ideas.
- Agrupa sus IDs y t√≠tulos seg√∫n cada tag.
- Guarda el resultado en un nuevo archivo JSON (ideaTagIndex.json).
```
const buildIndexTable = () => {
    const newIndex = {};
    for (const idea of ideas) {
      for (const tag of idea.tags) {
        const normalizedTag = tag.toLowerCase();
        if (!newIndex[normalizedTag]) newIndex[normalizedTag] = [];
        newIndex[normalizedTag].push({ ideaId: idea.ideaId, title: idea.title });
      }
    }
    localStorage.setItem("ideaTagIndex", JSON.stringify(newIndex));
    setIndexTable(newIndex);
    alert("√çndice reconstruido");
  };
```
#### Resultado
```
{
  "IA": [
    { "ideaId": "idea_101", "title": "Asistente educativo con IA" },
    { "ideaId": "idea_103", "title": "Detector de estr√©s con IA" }
  ],
  "Educaci√≥n": [
    { "ideaId": "idea_101", "title": "Asistente educativo con IA" }
  ]
}
```
### Funciones para la busqueda
```
const searchSlow = () => {
    const start = performance.now();
    const filtered = ideas.filter((idea) =>
      idea.tags.some((tag) => tag.toLowerCase().includes(query.toLowerCase()))
    );
    const end = performance.now();
    setResults(filtered);
    setMode("slow");
    setSearchTime((end - start).toFixed(3));
  };

  const searchFast = () => {
    const start = performance.now();
    const idx = indexTable[query.toLowerCase()] || [];
    const end = performance.now();
    setResults(idx);
    setMode("fast");
    setSearchTime((end - start).toFixed(3));
  };


```
### Comparacion
![Comparacion](./images/DemoPagina.png)
#### Buscamos por Tag "IOT"

![Comparacion](./images/lento.png)
Presionamos boton reconstruir indice
![Comparacion](./images/RAPIDO.png)
El tiempo de ejecuci√≥n de la b√∫squeda r√°pida es extremadamente corto (menor a 1 milisegundo) por lo que no se ve exactamente y confirma la mejora al integrar este patron

[Demo](./ITDEMO/)


---

[‚¨ÖÔ∏è Anterior](../0.7.3/0.7.3.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.7.5/0.7.5.md)