> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.8. Temas Individuales (Parte 2)](../0.8.md) ‚Ä∫ [0.8.2. Integrante 2](0.8.2.md)

# ESCALABILIDAD EN BASES DE DATOS: PARTITIONING Y SHARDING


# T√©cnicas de Particionado Horizontal para Escalabilidad
Este proyecto presenta dos demostraciones pr√°cticas enfocadas en t√©cnicas de escalabilidad horizontal aplicadas a bases de datos.

Se desarrollaron dos escenarios:

- **Demo 1:** Particionado Horizontal dentro de una misma base (Partitioning).
- **Demo 2:** Sharding Horizontal entre m√∫ltiples bases (con mini API).

Cada demo muestra c√≥mo optimizar consultas, distribuir carga y organizar datos para manejar sistemas de gran volumen.

---

## DEMO 1 ‚Äî Particionado Horizontal (Partitioning en SQL Server)

### Objetivo

El objetivo de esta demo es demostrar c√≥mo mejorar el rendimiento de consultas en tablas con alto volumen de datos utilizando **Partitioning**, que permite dividir f√≠sicamente una tabla en m√∫ltiples particiones basadas en un criterio (en este caso, fechas).

Optimizar consultas sobre una tabla grande dividi√©ndola internamente por rangos de fechas, logrando:

- Menos lecturas l√≥gicas
- Mejor tiempo de respuesta
- Mayor control sobre el almacenamiento
- Uso del mecanismo *"Partition Pruning"*

### Pasos Realizados

#### 1. Creaci√≥n de la Base de Datos

```sql
CREATE DATABASE DemoEscalabilidad;
GO
```

#### 2. Creaci√≥n de Tabla Masiva (Transacciones)

Se generaron 50,000 registros simulando actividad real:

```sql
CREATE TABLE Transacciones (
    IdTransaccion INT PRIMARY KEY,
    UsuarioId INT,
    Fecha DATE,
    Monto DECIMAL(10,2)
);
```

**Inserci√≥n de datos simulados:**

```sql
DECLARE @i INT = 1;
WHILE @i <= 50000
BEGIN
    INSERT INTO Transacciones VALUES (
        @i,
        (ABS(CHECKSUM(NEWID())) % 100000) + 1,
        DATEADD(DAY, -(@i % 365), GETDATE()),
        RAND() * 100
    );
    SET @i += 1;
END
```

#### 3. Consulta sin Particiones (para Comparar Rendimiento)

```sql
SELECT COUNT(*)
FROM Transacciones
WHERE Fecha BETWEEN '2025-01-01' AND '2025-06-30';
```

#### 4. Creaci√≥n del Partition Function

```sql
CREATE PARTITION FUNCTION pfTransacciones (DATE)
AS RANGE RIGHT FOR VALUES (
    ('2023-01-01'),
    ('2024-01-01'),
    ('2025-01-01')
);
```

#### 5. Creaci√≥n del Partition Scheme

```sql
CREATE PARTITION SCHEME psTransacciones
AS PARTITION pfTransacciones
TO ([PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY]);
```

#### 6. Creaci√≥n de la Tabla Particionada

*Nota: La columna Fecha debe formar parte de la clave primaria para cumplir con las reglas de SQL Server.*

```sql
CREATE TABLE Transacciones_Particionadas (
    IdTransaccion INT,
    UsuarioId INT,
    Fecha DATE,
    Monto DECIMAL(10,2),
    PRIMARY KEY (Fecha, IdTransaccion)
)
ON psTransacciones(Fecha);
```

#### 7. Inserci√≥n de Datos en la Tabla Particionada

```sql
INSERT INTO Transacciones_Particionadas
SELECT * FROM Transacciones;
```

#### 8. Consulta Optimizada Utilizando Particiones

```sql
SELECT COUNT(*)
FROM Transacciones_Particionadas
WHERE Fecha BETWEEN '2025-01-01' AND '2025-06-30';
```

### Resultados

- La consulta sobre la tabla particionada fue **significativamente m√°s r√°pida**.
- El Execution Plan mostr√≥ ***Partition Pruning***, indicando que SQL Server evalu√≥ √∫nicamente las particiones necesarias.
- Se demostr√≥ la diferencia entre consultar una tabla monol√≠tica vs. una tabla distribuida internamente.

---

## DEMO 2 ‚Äî Sharding Horizontal (SQL + Mini API en Node.js)

En esta demo implementamos **Sharding**, una t√©cnica de escalabilidad horizontal que divide los datos en m√∫ltiples bases de datos independientes, conocidas como *shards*.

### Objetivo

Simular c√≥mo un sistema distribuye usuarios entre m√∫ltiples bases y c√≥mo un backend decide a qu√© servidor conectarse seg√∫n cada consulta.

### Pasos Realizados

#### 1. Creaci√≥n de Shards Independientes

```sql
CREATE DATABASE ShardA;
CREATE DATABASE ShardB;
GO
```

#### 2. Creaci√≥n de Tabla Usuarios en Cada Shard

```sql
USE ShardA;
CREATE TABLE Usuarios (
    UsuarioId INT PRIMARY KEY,
    Nombre VARCHAR(100)
);

USE ShardB;
CREATE TABLE Usuarios (
    UsuarioId INT PRIMARY KEY,
    Nombre VARCHAR(100)
);
```

#### 3. Distribuci√≥n Horizontal de Usuarios

**Regla aplicada:**

- Usuarios con ID par ‚Üí **Shard A**
- Usuarios con ID impar ‚Üí **Shard B**

```sql
DECLARE @i INT = 1;

WHILE @i <= 100000
BEGIN
    IF (@i % 2 = 0)
        INSERT INTO ShardA.dbo.Usuarios VALUES (@i, CONCAT('Usuario ', @i));
    ELSE
        INSERT INTO ShardB.dbo.Usuarios VALUES (@i, CONCAT('Usuario ', @i));

    SET @i += 1;
END
```

#### 4. Creaci√≥n de Mini API (Routing Inteligente)

Se cre√≥ una API en Node.js capaz de decidir autom√°ticamente a qu√© shard conectarse seg√∫n el ID del usuario consultado.

**Dependencias:**

```bash
npm install express mssql
```

**C√≥digo del servidor (index.js):**

```javascript
const express = require('express');
const sql = require('mssql');

const app = express();

// SHARD A
const shardA = new sql.ConnectionPool({
    user: 'sa',
    password: '1234', // ejemplo
    server: 'localhost',
    database: 'ShardA',
    options: { trustServerCertificate: true }
}).connect();

// SHARD B
const shardB = new sql.ConnectionPool({
    user: 'sa',
    password: '1234',
    server: 'localhost',
    database: 'ShardB',
    options: { trustServerCertificate: true }
}).connect();

// L√≥gica de selecci√≥n de shard
function getShard(id) {
    return id % 2 === 0 ? shardA : shardB;
}

// Endpoint principal
app.get('/usuarios/:id', async (req, res) => {
    const id = parseInt(req.params.id);
    const pool = await getShard(id);

    const result = await (await pool).request()
        .input("id", sql.Int, id)
        .query("SELECT * FROM Usuarios WHERE UsuarioId = @id");

    res.send({
        shard: (id % 2 === 0) ? "ShardA" : "ShardB",
        data: result.recordset[0] ?? null
    });
});

app.listen(3000, () => {
    console.log("API de Sharding corriendo en http://localhost:3000");
});
```

### Pruebas

**Usuario 10 (par):**
```
GET http://localhost:3000/usuarios/10
```
‚Üí Devuelto desde ShardA

**Usuario 11 (impar):**
```
GET http://localhost:3000/usuarios/11
```
‚Üí Devuelto desde ShardB

### Resultados

- La API dirige autom√°ticamente cada consulta al shard correcto.
- La distribuci√≥n balanceada permite manejar mayor carga.
- Este patr√≥n escala linealmente agregando m√°s shards.
- Se simula un entorno real usado en sistemas como ***Instagram, Amazon y Twitter***.

---

## Conclusi√≥n

Ambas demostraciones ilustran t√©cnicas fundamentales de escalabilidad horizontal en bases de datos:

- **Partitioning** optimiza consultas dentro de una base √∫nica.
- **Sharding** distribuye datos entre m√∫ltiples bases para m√°xima escalabilidad.

Estas t√©cnicas son esenciales para arquitecturas modernas de alto rendimiento.



[‚¨ÖÔ∏è Anterior](../0.8.1/0.8.1.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.8.3/0.8.3.md)