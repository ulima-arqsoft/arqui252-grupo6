> [5. Tácticas](../5.md) › [5.1. Módulo 1 / Integrante 1](5.1.md)

# 5.1. Módulo 1 / Integrante 1

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Rendimiento** | **ESC-01** | Usuario realizando búsqueda | Usuario ejecuta búsqueda con palabra clave en base con 10k ideas | Motor de búsqueda del Módulo de Búsqueda de Ideas | Base de datos con 10,000 ideas indexadas | El sistema devuelve resultados ordenados por relevancia | Tiempo de respuesta p95 ≤ 1 seg | Garantiza experiencia fluida en búsquedas básicas |

### Táctica Elegida
La táctica elegida es **Introducir Concurrencia**, específicamente mediante el uso de índices invertidos y procesamiento paralelo de consultas.

**Título**:
- Táctica de Indexación Avanzada con Elasticsearch para Optimización de Búsquedas (ESC-01).

**Contexto**:
- Los usuarios de NEXUS necesitan encontrar ideas relevantes rápidamente mediante palabras clave (HU001). El requisito funcional **RF001** exige un tiempo de respuesta p95 ≤ 1s con 10k ideas. Las búsquedas full-text en bases de datos relacionales o búsquedas secuenciales son insuficientes para cumplir esta métrica bajo carga concurrente.

**Alternativas**:
1. **Introducir Concurrencia (Índices Invertidos + Procesamiento Paralelo)**:
    - Utilizar Elasticsearch con índices invertidos que permiten búsquedas full-text en tiempo casi constante O(1) para la localización de términos. El motor distribuye la consulta entre múltiples shards procesados en paralelo.
    - Proporciona búsquedas sub-segundo incluso con millones de documentos, scoring de relevancia avanzado (BM25).
2. **Incrementar Recursos Disponibles (Escalamiento Vertical)**:
    - Aumentar CPU y RAM del servidor de base de datos para acelerar consultas secuenciales.
    - Limitado por capacidad máxima del hardware, no resuelve el problema algorítmico de búsqueda full-text.

**Criterios de Elección**:
- Cumplir con métrica de rendimiento p95 ≤ 1s bajo carga concurrente.
- Escalabilidad horizontal para crecimiento futuro.
- Calidad de resultados con scoring de relevancia.

**Decisión**:
- Se elige la táctica de **Introducir Concurrencia** mediante Elasticsearch con arquitectura de sharding y réplicas.

**Sustento**:
- Los **índices invertidos** de Elasticsearch permiten localizar documentos que contienen términos específicos en tiempo casi constante. El procesamiento distribuido entre shards procesa la consulta en paralelo, agregando resultados finales. Con 3 shards primarios y 2 réplicas, el sistema puede procesar búsquedas concurrentes eficientemente, garantizando el **p95 ≤ 1s** requerido por RF001. Esta arquitectura escala horizontalmente agregando más nodos al clúster.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Rendimiento** | **ESC-02** | Usuario escribiendo en buscador | Usuario escribe consulta y activa autocompletado | Servicio de autocompletado del módulo | Interacción en tiempo real | El sistema muestra sugerencias relevantes sin duplicados | Tiempo de respuesta p95 ≤ 150 ms | Crítico para UX moderna y búsqueda predictiva |

### Táctica Elegida
La táctica elegida es **Incrementar Recursos Disponibles**, específicamente mediante el uso de caché distribuida (Redis) para consultas frecuentes.

**Título**:
- Implementación de Caché Distribuida para Autocompletado de Alta Velocidad (ESC-02).

**Contexto**:
- El autocompletado es una funcionalidad crítica para la experiencia de usuario (HU008). El requisito **RF005** exige p95 ≤ 150ms, lo cual es muy exigente. Consultar Elasticsearch directamente para cada pulsación de tecla consume recursos y puede no cumplir la métrica bajo carga alta.

**Alternativas**:
1. **Incrementar Recursos Disponibles (Caché Distribuida - Redis)**:
    - Precomputar y almacenar en Redis las sugerencias más frecuentes organizadas por prefijos (Trie structure). Las consultas de autocompletado golpean primero la caché.
    - Latencia sub-milisegundo desde Redis, reduce carga en Elasticsearch significativamente.
2. **Mantener Múltiples Copias (Réplicas de Elasticsearch)**:
    - Aumentar réplicas de Elasticsearch para distribuir carga de autocompletado.
    - Mayor costo de infraestructura, latencia sigue siendo mayor que caché en memoria.

**Criterios de Elección**:
- Cumplir con métrica ultra-exigente p95 ≤ 150ms.
- Reducir carga en Elasticsearch para optimizar costos.
- Experiencia de usuario fluida sin lag perceptible.

**Decisión**:
- Se elige la táctica de **Incrementar Recursos Disponibles** mediante caché distribuida Redis con estructura Trie para prefijos.

**Sustento**:
- Redis proporciona latencias de **< 1ms** para operaciones de lectura en memoria. Implementando una estructura Trie con los términos y prefijos más frecuentes (actualizada cada 5 minutos), el 80% de las consultas de autocompletado se resuelven desde caché. Para consultas no cacheadas, se ejecuta contra Elasticsearch con n-grams precomputados. Esta arquitectura híbrida garantiza el **p95 ≤ 150ms** requerido por RF005, mejorando significativamente la UX.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Disponibilidad** | **ESC-03** | Usuario con conexión inestable | Usuario pierde conectividad durante una búsqueda activa | Módulo de Búsqueda de Ideas | Uso normal con conexión intermitente | El sistema mantiene caché local y restaura estado al reconectarse | Restauración de estado ≤ 3 seg tras reconexión | Evita frustración y pérdida de contexto de búsqueda |

### Táctica Elegida
La táctica elegida es **Manejo de Excepciones**, específicamente mediante estrategias de reintentos y almacenamiento local de estado.

**Título**:
- Implementación de Caché Local y Estrategia de Reintentos para Resiliencia ante Desconexiones (ESC-03).

**Contexto**:
- Los usuarios móviles de NEXUS pueden experimentar conectividad intermitente (HU006). Perder el contexto de búsqueda (filtros aplicados, scroll position, términos ingresados) genera frustración. El sistema debe restaurar el estado completo en ≤ 3 seg tras reconexión.

**Alternativas**:
1. **Manejo de Excepciones (Reintentos + Estado Local)**:
    - La aplicación cliente almacena el estado de búsqueda (query, filtros, página actual) en Local Storage/IndexedDB. Al detectar reconexión, reintenta la consulta automáticamente con exponential backoff.
    - Restauración inmediata del contexto, experiencia fluida sin intervención del usuario.
2. **Sincronización (Estado en Servidor)**:
    - Mantener sesión de búsqueda en servidor con sincronización periódica.
    - Mayor complejidad, requiere autenticación persistente, mayor latencia de restauración.

**Criterios de Elección**:
- Velocidad de restauración ≤ 3 seg tras reconexión.
- Independencia de disponibilidad del servidor durante desconexión.
- Simplicidad de implementación en cliente móvil.

**Decisión**:
- Se elige la táctica de **Manejo de Excepciones** mediante almacenamiento local de estado y reintentos automáticos con exponential backoff.

**Sustento**:
- Al almacenar el estado de búsqueda (query, filtros activos, resultados visualizados, scroll position) en **Local Storage** del navegador o **AsyncStorage** en React Native, la aplicación puede restaurar inmediatamente la UI al detectar reconexión. La estrategia de reintentos (3 intentos con delays de 1s, 2s, 4s) permite recuperar datos actualizados del servidor mientras muestra datos cacheados. Esta arquitectura garantiza **restauración ≤ 3s** y proporciona experiencia offline-first alineada con PWA best practices.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Seguridad** | **ESC-04** | Usuario autenticado | Usuario intenta acceder a ideas privadas/compartidas | Sistema de control de acceso del módulo | Múltiples niveles de visibilidad activos | El sistema filtra resultados según permisos del usuario | 100% de ideas respetan visibilidad configurada | Protege privacidad y confidencialidad de ideas |

### Táctica Elegida
La táctica elegida es **Limitar el Acceso**, específicamente mediante filtros de seguridad a nivel de consulta (Row-Level Security).

**Título**:
- Implementación de Filtrado de Visibilidad a Nivel de Consulta para Garantizar Seguridad (ESC-04).

**Contexto**:
- NEXUS maneja tres niveles de visibilidad: pública, privada y compartida (RF007). El requisito crítico es que **100% de ideas respeten su configuración de visibilidad** en todo momento. Un error de seguridad podría exponer ideas confidenciales y destruir la confianza en la plataforma.

**Alternativas**:
1. **Limitar el Acceso (Filtros de Seguridad a Nivel de Consulta)**:
    - Inyectar automáticamente cláusulas de filtrado en todas las consultas a Elasticsearch basadas en el contexto de seguridad del usuario autenticado: `(visibility:public OR owner_id:{user_id} OR shared_with:{user_id})`.
    - Garantía de seguridad a nivel de datos, imposible bypassear desde cliente.
2. **Autorizar (Verificación Post-Consulta)**:
    - Obtener todos los resultados y filtrar en capa de aplicación.
    - Ineficiente, paginación incorrecta, mayor latencia, riesgo de fugas si hay bug en código de aplicación.

**Criterios de Elección**:
- Garantía absoluta de seguridad (100% compliance).
- Performance sin degradación significativa.
- Imposibilidad de bypass por errores en cliente.

**Decisión**:
- Se elige la táctica de **Limitar el Acceso** mediante filtros de seguridad inyectados automáticamente a nivel de consulta Elasticsearch.

**Sustento**:
- Implementando un **Security Context Interceptor** en el microservicio de búsqueda, todas las consultas a Elasticsearch incluyen automáticamente las cláusulas de visibilidad basadas en el JWT del usuario. El índice de Elasticsearch contiene campos `visibility`, `owner_id` y `shared_with[]` sincronizados desde MongoDB vía Change Streams. Los filtros booleanos de Elasticsearch son extremadamente eficientes (filtro en cached segments), garantizando **100% compliance** sin degradación de performance, cumpliendo ESC-04.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Rendimiento** | **ESC-05** | Múltiples usuarios simultáneos | 500+ usuarios realizan búsquedas complejas concurrentemente | Servidor de búsqueda y base de datos | Pico de tráfico en horario prime | El sistema mantiene tiempos de respuesta aceptables mediante caché e indexación | p95 ≤ 2 seg, p99 ≤ 3 seg | Asegura escalabilidad en momentos de alta demanda |

### Táctica Elegida
La táctica elegida es **Mantener Múltiples Copias**, específicamente mediante replicación activa de servicios y sharding de datos.

**Título**:
- Implementación de Escalamiento Horizontal con Replicación y Sharding para Alta Concurrencia (ESC-05).

**Contexto**:
- NEXUS espera picos de tráfico durante eventos de marketing o lanzamientos importantes. El Módulo 1 debe soportar 500+ usuarios realizando búsquedas complejas (múltiples filtros, ordenamiento) simultáneamente, manteniendo p95 ≤ 2s y p99 ≤ 3s.

**Alternativas**:
1. **Mantener Múltiples Copias (Replicación + Sharding)**:
    - Desplegar múltiples instancias del microservicio de búsqueda con balanceador de carga (ALB). Configurar Elasticsearch con 3 shards primarios y 2 réplicas por shard distribuidas en 3 nodos.
    - Distribuye carga entre réplicas de servicio y paraleliza consultas entre shards de datos.
2. **Incrementar Recursos (Escalamiento Vertical)**:
    - Aumentar capacidad de servidor único con más CPU/RAM.
    - Límite físico de hardware, punto único de falla, mayor costo por unidad de capacidad.

**Criterios de Elección**:
- Soportar 500+ usuarios concurrentes sin degradación.
- Cumplir métricas p95 ≤ 2s, p99 ≤ 3s bajo pico de carga.
- Elasticidad para crecer/decrecer según demanda.

**Decisión**:
- Se elige la táctica de **Mantener Múltiples Copias** mediante auto-scaling horizontal del microservicio y arquitectura distribuida de Elasticsearch.

**Sustento**:
- Desplegando el microservicio en **Kubernetes con HPA** (Horizontal Pod Autoscaler) configurado para escalar de 2 a 10 réplicas basado en CPU > 70% y latencia p95, el sistema distribuye automáticamente la carga. Elasticsearch con **3 shards primarios + 2 réplicas** distribuye consultas en paralelo entre 9 copias de datos (3×3). Un Application Load Balancer distribuye tráfico con round-robin entre réplicas de servicio. Esta arquitectura garantiza **p95 ≤ 2s** y **p99 ≤ 3s** durante picos de 500+ usuarios concurrentes, cumpliendo ESC-05.

---
[🏠 Home](../../README.md) | [Siguiente ➡️](../5.2/5.2.md)