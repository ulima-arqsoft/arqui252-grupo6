> [5. Tácticas](../5.md) › [5.1. Módulo 1 / Integrante 1](5.1.md)

# 5.1. Módulo 1 / Integrante 1

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Rendimiento** | **ESC-01** | Usuario realizando búsqueda | Usuario ejecuta búsqueda con palabra clave en base con 10k ideas | Motor de búsqueda del Módulo de Búsqueda de Ideas | Base de datos con 10,000 ideas indexadas | El sistema devuelve resultados ordenados por relevancia | Tiempo de respuesta p95 ≤ 1 seg | Garantiza experiencia fluida en búsquedas básicas |

### Táctica Elegida
La táctica elegida es **Introducir Concurrencia**, específicamente mediante el uso de índices invertidos y procesamiento paralelo de consultas.

**Título**:
- Táctica de Indexación Avanzada con Elasticsearch para Optimización de Búsquedas (ESC-01).

**Contexto**:
- Los usuarios de NEXUS necesitan encontrar ideas relevantes rápidamente mediante palabras clave (HU001). El requisito funcional **RF001** exige un tiempo de respuesta p95 ≤ 1s con 10k ideas. Las búsquedas full-text en bases de datos relacionales o búsquedas secuenciales son insuficientes para cumplir esta métrica bajo carga concurrente.

**Alternativas**:
1. **Introducir Concurrencia (Índices Invertidos + Procesamiento Paralelo)**:
    - Utilizar Elasticsearch con índices invertidos que permiten búsquedas full-text en tiempo casi constante O(1) para la localización de términos. El motor distribuye la consulta entre múltiples shards procesados en paralelo.
    - Proporciona búsquedas sub-segundo incluso con millones de documentos, scoring de relevancia avanzado (BM25).
2. **Incrementar Recursos Disponibles (Escalamiento Vertical)**:
    - Aumentar CPU y RAM del servidor de base de datos para acelerar consultas secuenciales.
    - Limitado por capacidad máxima del hardware, no resuelve el problema algorítmico de búsqueda full-text.

**Criterios de Elección**:
- Cumplir con métrica de rendimiento p95 ≤ 1s bajo carga concurrente.
- Escalabilidad horizontal para crecimiento futuro.
- Calidad de resultados con scoring de relevancia.

**Decisión**:
- Se elige la táctica de **Introducir Concurrencia** mediante Elasticsearch con arquitectura de sharding y réplicas.

**Sustento**:
- Los **índices invertidos** de Elasticsearch permiten localizar documentos que contienen términos específicos en tiempo casi constante. El procesamiento distribuido entre shards procesa la consulta en paralelo, agregando resultados finales. Con 3 shards primarios y 2 réplicas, el sistema puede procesar búsquedas concurrentes eficientemente, garantizando el **p95 ≤ 1s** requerido por RF001. Esta arquitectura escala horizontalmente agregando más nodos al clúster.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Disponibilidad** | **ESC-03** | Usuario con conexión inestable | Usuario pierde conectividad durante una búsqueda activa | Módulo de Búsqueda de Ideas | Uso normal con conexión intermitente | El sistema mantiene caché local y restaura estado al reconectarse | Restauración de estado ≤ 3 seg tras reconexión | Evita frustración y pérdida de contexto de búsqueda |

### Táctica Elegida
La táctica elegida es **Manejo de Excepciones**, específicamente mediante estrategias de reintentos y almacenamiento local de estado.

**Título**:
- Implementación de Caché Local y Estrategia de Reintentos para Resiliencia ante Desconexiones (ESC-03).

**Contexto**:
- Los usuarios móviles de NEXUS pueden experimentar conectividad intermitente (HU006). Perder el contexto de búsqueda (filtros aplicados, scroll position, términos ingresados) genera frustración. El sistema debe restaurar el estado completo en ≤ 3 seg tras reconexión.

**Alternativas**:
1. **Manejo de Excepciones (Reintentos + Estado Local)**:
    - La aplicación cliente almacena el estado de búsqueda (query, filtros, página actual) en Local Storage/IndexedDB. Al detectar reconexión, reintenta la consulta automáticamente con exponential backoff.
    - Restauración inmediata del contexto, experiencia fluida sin intervención del usuario.
2. **Sincronización (Estado en Servidor)**:
    - Mantener sesión de búsqueda en servidor con sincronización periódica.
    - Mayor complejidad, requiere autenticación persistente, mayor latencia de restauración.

**Criterios de Elección**:
- Velocidad de restauración ≤ 3 seg tras reconexión.
- Independencia de disponibilidad del servidor durante desconexión.
- Simplicidad de implementación en cliente móvil.

**Decisión**:
- Se elige la táctica de **Manejo de Excepciones** mediante almacenamiento local de estado y reintentos automáticos con exponential backoff.

**Sustento**:
- Al almacenar el estado de búsqueda (query, filtros activos, resultados visualizados, scroll position) en **Local Storage** del navegador o **AsyncStorage** en React Native, la aplicación puede restaurar inmediatamente la UI al detectar reconexión. La estrategia de reintentos (3 intentos con delays de 1s, 2s, 4s) permite recuperar datos actualizados del servidor mientras muestra datos cacheados. Esta arquitectura garantiza **restauración ≤ 3s** y proporciona experiencia offline-first alineada con PWA best practices.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Seguridad** | **ESC-04** | Usuario autenticado | Usuario intenta acceder a ideas privadas/compartidas | Sistema de control de acceso del módulo | Múltiples niveles de visibilidad activos | El sistema filtra resultados según permisos del usuario | 100% de ideas respetan visibilidad configurada | Protege privacidad y confidencialidad de ideas |

### Táctica Elegida
La táctica elegida es **Limitar el Acceso**, específicamente mediante filtros de seguridad a nivel de consulta (Row-Level Security).

**Título**:
- Implementación de Filtrado de Visibilidad a Nivel de Consulta para Garantizar Seguridad (ESC-04).

**Contexto**:
- NEXUS maneja tres niveles de visibilidad: pública, privada y compartida (RF007). El requisito crítico es que **100% de ideas respeten su configuración de visibilidad** en todo momento. Un error de seguridad podría exponer ideas confidenciales y destruir la confianza en la plataforma.

**Alternativas**:
1. **Limitar el Acceso (Filtros de Seguridad a Nivel de Consulta)**:
    - Inyectar automáticamente cláusulas de filtrado en todas las consultas a Elasticsearch basadas en el contexto de seguridad del usuario autenticado: `(visibility:public OR owner_id:{user_id} OR shared_with:{user_id})`.
    - Garantía de seguridad a nivel de datos, imposible bypassear desde cliente.
2. **Autorizar (Verificación Post-Consulta)**:
    - Obtener todos los resultados y filtrar en capa de aplicación.
    - Ineficiente, paginación incorrecta, mayor latencia, riesgo de fugas si hay bug en código de aplicación.

**Criterios de Elección**:
- Garantía absoluta de seguridad (100% compliance).
- Performance sin degradación significativa.
- Imposibilidad de bypass por errores en cliente.

**Decisión**:
- Se elige la táctica de **Limitar el Acceso** mediante filtros de seguridad inyectados automáticamente a nivel de consulta Elasticsearch.

**Sustento**:
- Implementando un **Security Context Interceptor** en el microservicio de búsqueda, todas las consultas a Elasticsearch incluyen automáticamente las cláusulas de visibilidad basadas en el JWT del usuario. El índice de Elasticsearch contiene campos `visibility`, `owner_id` y `shared_with[]` sincronizados desde MongoDB vía Change Streams. Los filtros booleanos de Elasticsearch son extremadamente eficientes (filtro en cached segments), garantizando **100% compliance** sin degradación de performance, cumpliendo ESC-04.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Usabilidad** | **ESC-06** | Usuario en dispositivo móvil | Usuario navega resultados y aplica filtros desde pantalla pequeña | Interfaz responsive del Módulo de Búsqueda | Dispositivo móvil con pantalla < 6" | Interfaz adaptada con filtros colapsables y navegación táctil optimizada | 100% funcionalidades accesibles, tap targets ≥ 44px | Fundamental para accesibilidad móvil |

### Táctica Elegida
La táctica elegida es **Separar Interfaz de Usuario del Resto del Sistema**, aplicando el patrón de diseño responsive con componentes adaptativos.

**Título**:
- Implementación de Diseño Responsive con Mobile-First Approach para Usabilidad Móvil (ESC-06).

**Contexto**:
- Los usuarios de NEXUS acceden desde diversos dispositivos, siendo móviles (< 6") una porción significativa. El requisito **HU005** y **ESC-06** exigen que el 100% de funcionalidades sean accesibles en móvil con tap targets ≥ 44px según estándares de accesibilidad. Los filtros complejos (categoría, tags, habilidades) deben ser usables en pantallas pequeñas.

**Alternativas**:
1. **Separar Interfaz de Usuario (Responsive Design + Componentes Adaptativos)**:
    - Implementar diseño mobile-first con Tailwind CSS y componentes React que se adaptan según viewport. Filtros se presentan en modal/drawer colapsable en móvil, expandido en desktop.
    - Experiencia optimizada por dispositivo, misma base de código, mantenibilidad alta.
2. **Desarrollar Aplicaciones Nativas Separadas**:
    - Crear aplicaciones nativas específicas para iOS/Android con UI optimizada.
    - Mayor costo de desarrollo y mantenimiento, requiere equipos especializados por plataforma.

**Criterios de Elección**:
- Accesibilidad completa (100% funcionalidades) en dispositivos móviles.
- Cumplimiento de estándares de usabilidad (tap targets ≥ 44px).
- Eficiencia en desarrollo y mantenimiento.

**Decisión**:
- Se elige la táctica de **Separar Interfaz de Usuario** mediante diseño responsive con enfoque mobile-first.

**Sustento**:
- Implementando **React Native Web** con Tailwind CSS, la aplicación detecta viewport y adapta la UI automáticamente. En móvil (< 768px): filtros se presentan en **drawer deslizable** activado por botón flotante, resultados en cards verticales optimizadas para scroll táctil, tap targets de mínimo 44x44px según WCAG 2.1. En desktop: filtros en sidebar lateral fija, resultados en grid multi-columna. Los componentes compartidos (SearchBar, ResultCard, FilterGroup) encapsulan lógica responsive, garantizando **100% funcionalidades accesibles** en cualquier dispositivo, cumpliendo ESC-06.

---

## Escenario
| Atributo | ID Escenario | Fuente Estímulo | Estímulo | Artefacto | Entorno | Respuesta | Medida de Respuesta | Comentario |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Modificabilidad** | **ESC-08** | Equipo de desarrollo | Se requiere agregar nuevo tipo de filtro (ej: ubicación geográfica) | Código fuente del Módulo de Búsqueda | Evolución del sistema | Arquitectura permite extensión sin modificar lógica existente | Implementación ≤ 2 días, 0% regresión | Facilita evolución y adición de funcionalidades |

### Táctica Elegida
La táctica elegida es **Aumentar Cohesión Semántica**, específicamente mediante el patrón Strategy y Plugin Architecture para filtros.

**Título**:
- Implementación de Arquitectura de Plugins para Filtros Extensibles (ESC-08).

**Contexto**:
- NEXUS necesita evolucionar continuamente agregando nuevos tipos de filtros según las necesidades de los usuarios (ubicación, presupuesto, fecha límite). El requisito **ESC-08** exige que agregar un nuevo filtro tome ≤ 2 días sin causar regresiones. La arquitectura actual debe facilitar esta extensibilidad.

**Alternativas**:
1. **Aumentar Cohesión Semántica (Patrón Strategy + Plugin Architecture)**:
    - Definir una interfaz `FilterStrategy` que cada tipo de filtro implementa. El motor de búsqueda aplica filtros de manera polimórfica. Nuevos filtros se agregan como plugins sin modificar código core.
    - Extensibilidad sin modificar código existente (Open/Closed Principle), testing aislado de cada filtro.
2. **Código Monolítico con Condicionales**:
    - Agregar cada nuevo filtro mediante if/switch statements en el código principal.
    - Requiere modificar múltiples archivos, alto riesgo de regresión, testing completo necesario.

**Criterios de Elección**:
- Tiempo de implementación ≤ 2 días para nuevo filtro.
- Riesgo de regresión minimizado (0%).
- Facilidad de testing de nuevas funcionalidades.

**Decisión**:
- Se elige la táctica de **Aumentar Cohesión Semántica** mediante arquitectura de plugins con patrón Strategy.

**Sustento**:
- Definiendo una interfaz `FilterStrategy` con métodos `apply(query, params)` y `validate(params)`, cada tipo de filtro (CategoryFilter, TagFilter, SkillFilter) implementa su lógica de manera aislada. El **FilterEngine** aplica todos los filtros activos iterando sobre la colección de strategies registradas. Para agregar filtro de ubicación: (1) Crear clase `LocationFilter implements FilterStrategy` (4 horas), (2) Registrar en FilterRegistry (30 min), (3) Tests unitarios (2 horas), (4) Documentación (1 hora). Total: **< 1 día**, con **0% regresión** ya que no se modifica código existente, cumpliendo ESC-08.


---
[🏠 Home](../../README.md) | [Siguiente ➡️](../5.2/5.2.md)