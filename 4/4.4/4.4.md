> [4. Decisiones Iniciales de Arquitectura](../4.md) ‚Ä∫ [4.4. M√≥dulo 4 / Integrante 4](4.4.md)

# 4.4. M√≥dulo 4 / Integrante 4

## Decisi√≥n 1 (Modelo de Datos)

**T√≠tulo**:

- Elecci√≥n de un Modelo (NoSQL) para el Repositorio Principal de Ideas

**Contexto**:

El M√≥dulo 2 gestiona la creaci√≥n, edici√≥n y almacenamiento de las ideas. Estas ideas contienen informaci√≥n variada y no estrictamente relacional: t√≠tulo, descripci√≥n detallada (texto enriquecido), una lista de tecnolog√≠as requeridas, etiquetas (tags), presupuesto y plazos. La principal operaci√≥n es la lectura/b√∫squeda de estas ideas (M√≥dulo 3), que debe ser muy r√°pida.

**Alternativas**:

1. **Modelo Relacional (PostgreSQL):**
    - Almacenar la idea en m√∫ltiples tablas normalizadas (ej., una tabla para Ideas, otra para Tecnolog√≠as, otra para Etiquetas).
    - Alta integridad de datos, excelente para reportes estructurados y manejo de transacciones complejas.
    - Rigidez de esquema que dificultar√≠a la r√°pida evoluci√≥n. Las consultas de lectura (joins para obtener todos los datos de una idea) podr√≠an ser menos eficientes que en un modelo documental.

2. **Modelo Documental (MongoDB o similar):**
    - Almacenar toda la informaci√≥n de una idea (incluyendo la lista de tecnolog√≠as y etiquetas) en un √∫nico documento JSON.
    - Flexibilidad total en el esquema, lo que facilita agregar campos sin impactar el frontend o backend (ideal para el contexto de startup). Lectura muy r√°pida (una sola consulta a la base de datos para obtener todos los datos de la idea).
    - Menor control de la integridad referencial (no hay Foreign Keys nativas), transacciones limitadas a nivel de documento.

**Criterios de Elecci√≥n:**

- Flexibilidad del Esquema: Necesidad de adaptarse a nuevas funcionalidades y cambios r√°pidos en la estructura de la idea.
- Velocidad de Lectura: Prioridad en la rapidez con la que se obtienen todos los datos de una idea para su visualizaci√≥n y b√∫squeda.
- Complejidad Transaccional: Las operaciones de creaci√≥n/edici√≥n de ideas son simples y no requieren transacciones complejas en m√∫ltiples entidades.

**Decisi√≥n:**

Se elige un Modelo Documental (NoSQL) para el repositorio principal de las publicaciones de ideas.

**Sustento:**

- La flexibilidad de esquema proporcionada por el modelo documental es esencial para el M√≥dulo 2, ya que permite a NEXUS iterar r√°pidamente sobre lo que se considera una "buena publicaci√≥n de idea" (HU012).
- La alta velocidad de lectura de documentos autocontenidos (todos los datos en un solo lugar) optimiza el rendimiento para el M√≥dulo 3: B√∫squeda, que es una funci√≥n cr√≠tica.
- La baja complejidad transaccional del proceso de publicaci√≥n de ideas hace que la falta de soporte ACID nativo para m√∫ltiples documentos sea un riesgo aceptable en este m√≥dulo.

--- 
## Decisi√≥n 2

**T√≠tulo:**
Elecci√≥n entre Framework Nativo, Flutter y React Native + Expo para frontend m√≥vil

**Contexto:**
Aplicaci√≥n m√≥vil debe soportar iOS y Android simult√°neamente. Equipo con experiencia en React. 

**Alternativas:**

1. **Desarrollo Nativo (Swift + Kotlin)**
   - M√°ximo rendimiento; mejor UX.
   - Requiere equipos especializados; duplicaci√≥n de c√≥digo.

2. **Flutter + Dart**
   - Un codebase para ambas plataformas; compilaci√≥n nativa.
   - Dart es nuevo para equipo; comunidad m√°s peque√±a.

3. **React Native + Expo**
   - Sintaxis React familiar; 80-90% c√≥digo compartido.
   - Rendimiento ligeramente inferior

**Criterios de Elecci√≥n:**
- Alineaci√≥n con experiencia del equipo
- Velocidad de desarrollo
- Reutilizaci√≥n de c√≥digo
- Acceso a caracter√≠sticas nativas

**Decisi√≥n:**
Se elige **React Native + Expo**.

**Sustento:**
El equipo domina React; la transici√≥n a React Native es m√≠nima. Expo elimina complejidad de Xcode y Android Studio. Caracter√≠sticas nativas requeridas (notificaciones, c√°mara, GPS) est√°n cubiertas por m√≥dulos de Expo. Un √∫nico codebase reduce tiempo de desarrollo. La comunidad React Native es masiva; librer√≠as disponibles para casos de uso comunes. Para NEXUS, el rendimiento de React Native es suficiente.

---

## Decisi√≥n 3

**T√≠tulo:**
Elecci√≥n entre Lenguaje Tipado Est√°tico vs o Tipado Din√°mico para NEXUS

**Contexto:**
Equipo de 5 con experiencia en JavaScript/TypeScript. Necesidad de desarrollo r√°pido en frontend m√≥vil, web y backend.

**Alternativas:**

1. **Lenguaje de Tipado Est√°tico (Java, Swift, Kotlin)**
   - Seguridad de tipos en compilaci√≥n; mejor rendimiento nativo.
   - Requiere m√∫ltiples lenguajes y equipos especializados.

2. **Lenguaje de Tipado Din√°mico (JavaScript/TypeScript)**
   - Un √∫nico lenguaje en todo el stack

**Criterios de Elecci√≥n:**
- Velocidad de desarrollo
- Experiencia del equipo
- Unificaci√≥n del stack
- Flexibilidad para cambios

**Decisi√≥n:**
Se elige **JavaScript/TypeScript** como lenguaje principal.

**Sustento:**
El equipo domina JavaScript/TypeScript, lo que permite productividad inmediata. Un √∫nico lenguaje en backend, frontend web y mobile simplifica la arquitectura y permite que desarrolladores trabajen en m√∫ltiples capas. TypeScript proporciona seguridad de tipos en desarrollo. El ecosistema npm es maduro con librer√≠as para pagos, chat, autenticaci√≥n. Esto es cr√≠tico para cumplir timeline de 5-6 meses.

---
## Decisi√≥n 4

**T√≠tulo:**
Elecci√≥n entre Express.js, Django/Flask, Spring Boot y NestJS para backend

**Contexto:**
Backend debe soportar b√∫squeda, chat en tiempo real (WebSockets), pagos, autenticaci√≥n. Equipo con experiencia en Node.js/Express y TypeScript. Requiere arquitectura escalable.

**Alternativas:**

1. **Express.js Puro**
   - Libertad total; footprint peque√±o.
   - Arquitectura casera; boilerplate manual; dif√≠cil de escalar.

2. **Django/Flask**
   - Framework robusto (Django); prototipado r√°pido (Flask).
   - Equipo sin experiencia en Python; lenguaje diferente al frontend.

3. **Spring Boot**
   - Enterprise-grade; rendimiento excelente.
   - Equipo sin experiencia en Java; curva aprendizaje muy pronunciada.

4. **NestJS**
   - Arquitectura clara basada en TypeScript; modular.
   - WebSockets nativo (Socket.io); inyecci√≥n de dependencias.

**Criterios de Elecci√≥n:**
- Alineaci√≥n con experiencia del equipo
- Arquitectura escalable desde inicio
- WebSockets para chat en tiempo real
- Robustez para pagos
- TypeScript compartido con frontend

**Decisi√≥n:**
Se elige **NestJS**.

**Sustento:**
NestJS est√° construido sobre Express.js; el equipo es productivo inmediatamente. Proporciona arquitectura clara con decoradores, inyecci√≥n de dependencias y m√≥dulos sin requerer configuraci√≥n manual. TypeScript compartido entre backend y frontend permite reutilizaci√≥n de tipos e interfaces. Socket.io integrado nativamente para chat. Escalable a microservicios. Comunidad Node.js es masiva. Esto permite cumplir timeline y mantener coherencia en el stack de JavaScript/TypeScript.

Perfecto üî• Aqu√≠ tienes la **ADR completa** para la elecci√≥n de **AWS S3** como servicio de almacenamiento de archivos est√°ticos, siguiendo el mismo formato y tono profesional que la decisi√≥n anterior de Stripe, totalmente adaptada al contexto de **NEXUS**.

---

# Decision 5

**T√≠tulo:**

* Elecci√≥n de servicio de almacenamiento para archivos est√°ticos entre **AWS S3**, **Google Cloud Storage** y **Firebase Storage**.

---

**Contexto:**
El m√≥dulo de **Publicaci√≥n de Ideas** y **Gesti√≥n de Perfil** en **NEXUS** requiere un sistema confiable y escalable para **almacenar archivos est√°ticos**, como:

* Im√°genes de perfil, banners y portadas de ideas.
* Archivos adjuntos asociados a proyectos (documentos, presentaciones, prototipos, etc.).
* Recursos multimedia utilizados en las publicaciones de la comunidad.

La plataforma est√° concebida como un sistema **multiplataforma (web y m√≥vil)**, con una arquitectura orientada a servicios y microcomponentes (backend en **Node.js/Express**). Por lo tanto, el servicio de almacenamiento debe integrarse f√°cilmente con el backend y permitir **acceso p√∫blico controlado** mediante URLs seguras o pre-firmadas.

Adem√°s, dado que el proyecto **NEXUS apunta a escalar globalmente**, se requiere una soluci√≥n **con alta disponibilidad, bajo costo por almacenamiento y distribuci√≥n r√°pida de contenido**.

---

**Alternativas:**

1. **AWS S3 (Amazon Simple Storage Service)**

   * Servicio maduro y ampliamente utilizado para almacenamiento de objetos.
   * Ofrece **alta durabilidad (99.999999999%)** y disponibilidad global.
   * Integraci√≥n directa con el ecosistema AWS (CloudFront, IAM, Lambda, etc.).
   * Permite **presigned URLs** para control de acceso temporal a archivos.
   * Compatible con SDKs para m√∫ltiples lenguajes (Node.js, Python, etc.).
   * Escalabilidad autom√°tica sin configuraci√≥n adicional.
   * Costo promedio: **$0.023 por GB/mes** (S3 Standard).

2. **Google Cloud Storage (GCS)**

   * Ofrece una API muy similar a S3, con buen rendimiento y fiabilidad.
   * Integraci√≥n directa con servicios de Google Cloud (Compute Engine, BigQuery).
   * Panel de administraci√≥n intuitivo y pol√≠ticas de seguridad potentes.
   * Buen soporte para almacenamiento de datos est√°ticos y p√∫blicos.
   * Costo promedio: **$0.020 por GB/mes**, aunque con menor disponibilidad de regiones en LATAM.
   * Menor compatibilidad directa con herramientas de AWS ya usadas en otros m√≥dulos del sistema.

3. **Firebase Storage**

   * Ideal para apps m√≥viles con integraci√≥n directa con Firebase Auth y Firestore.
   * Sin necesidad de configurar servidores intermedios para subir archivos.
   * L√≠mite pr√°ctico de tama√±o de archivo menor y **costos m√°s altos** al escalar.
   * No est√° dise√±ado para grandes vol√∫menes de datos ni distribuci√≥n global masiva.
   * Dependencia de todo el ecosistema Firebase (menos modular).
   * Costo promedio: **$0.026 por GB/mes** m√°s costo de descarga.

---

**Criterios de Elecci√≥n:**

* **Escalabilidad**: capacidad para manejar miles de archivos y peticiones simult√°neas.
* **Seguridad y control de acceso**: soporte de pol√≠ticas IAM y URLs firmadas.
* **Integraci√≥n t√©cnica**: compatibilidad con Node.js y frameworks del backend.
* **Costo total**: almacenamiento, transferencias y peticiones.
* **Disponibilidad global y rendimiento de entrega.**
* **Durabilidad y confiabilidad del servicio.**
* **Flexibilidad para usar CDN y cacheo de archivos est√°ticos.**

---

**Decisi√≥n:**

* Se elige **AWS S3** como servicio principal de almacenamiento de archivos est√°ticos para NEXUS.

---

**Sustento:**

* **AWS S3** ofrece una **combinaci√≥n √≥ptima de rendimiento, seguridad y escalabilidad**, ideal para una aplicaci√≥n en crecimiento como **NEXUS**.
* Su integraci√≥n con **AWS CloudFront** permitir√° distribuir archivos est√°ticos globalmente con baja latencia.
* Las **presigned URLs** de S3 simplifican el manejo seguro de archivos por parte de los usuarios, sin exponer credenciales ni rutas internas.
* **El ecosistema AWS** brinda ventajas de interoperabilidad con futuros componentes (logs, an√°lisis, backups).
---
Perfecto üí™ Aqu√≠ tienes la **ADR completa** para la elecci√≥n de **SendGrid** como servicio de env√≠o de correos electr√≥nicos en **NEXUS**, siguiendo la misma estructura y nivel de detalle profesional que las anteriores (Stripe y S3).

---

# Decision 6

**T√≠tulo:**

* Elecci√≥n del servicio de mensajer√≠a por correo electr√≥nico entre **SendGrid**, **Amazon SES** y **Mailgun** para NEXUS.

---

**Contexto:**
La aplicaci√≥n **NEXUS** requiere un sistema confiable para **enviar correos electr√≥nicos autom√°ticos y transaccionales** en distintos puntos de interacci√≥n del usuario, tales como:

* Confirmaci√≥n de registro e inicio de sesi√≥n.
* Notificaciones de nuevas colaboraciones o comentarios en ideas.
* Restablecimiento de contrase√±a.
* Alertas y recordatorios sobre actividades o recompensas.

El sistema debe ofrecer **alta entregabilidad (deliverability)**, **bajo porcentaje de spam**, y una **API sencilla** para integrarse con el backend desarrollado en **Node.js (Express)**.

Asimismo, es importante contar con **reportes de env√≠o**, **m√©tricas de apertura** y **capacidad de personalizaci√≥n de plantillas** para mantener la identidad visual de NEXUS.

El servicio debe escalar a medida que la base de usuarios crezca, sin requerir configuraciones complejas de servidores SMTP propios.

---

**Alternativas:**

1. **SendGrid (by Twilio)**

   * Amplio reconocimiento en el mercado por su confiabilidad y API moderna.
   * Ofrece **API RESTful** f√°cil de integrar con Node.js, Python y otros lenguajes.
   * Soporta **plantillas din√°micas**, env√≠o masivo y segmentaci√≥n de usuarios.
   * Alta entregabilidad y herramientas para an√°lisis de rendimiento (open rate, bounce rate, spam reports).
   * Permite autenticaci√≥n segura mediante **API keys** y configuraci√≥n de **dominios verificados (SPF, DKIM)**.
   * Plan gratuito inicial con hasta **100 correos/d√≠a**, escalable seg√∫n uso.

2. **Amazon SES (Simple Email Service)**

   * Integraci√≥n directa con el ecosistema AWS.
   * Costos muy bajos (**~$0.10 por cada 1,000 correos enviados**).
   * Alta confiabilidad y reputaci√≥n de env√≠o.
   * Sin embargo, la **configuraci√≥n inicial es compleja**, especialmente para gestionar plantillas o m√©tricas de usuarios no t√©cnicos.
   * Menor enfoque en herramientas de marketing o visualizaci√≥n.
   * API menos amigable para integraciones r√°pidas y gesti√≥n de plantillas din√°micas.

3. **Mailgun**

   * Servicio robusto con buena reputaci√≥n y API clara.
   * Ofrece funcionalidades similares a SendGrid (tracking, plantillas, validaci√≥n de emails).
   * Sin embargo, su **plan gratuito es limitado (50 correos/mes)**.
   * Su interfaz de administraci√≥n es menos intuitiva.
   * En algunos pa√≠ses de LATAM, puede presentar **retrasos en entrega o bloqueos por IPs compartidas**.

---

**Criterios de Elecci√≥n:**

* **Entregabilidad** (deliverability) y reputaci√≥n de dominio.
* **Facilidad de integraci√≥n con Node.js (API RESTful o SDK)**.
* **Gesti√≥n de plantillas y personalizaci√≥n de correos.**
* **Costo y escalabilidad** seg√∫n volumen de usuarios.
* **M√©tricas y anal√≠ticas de env√≠o.**
* **Soporte t√©cnico y documentaci√≥n.**
* **Facilidad de configuraci√≥n inicial (SPF, DKIM, etc.).**

---

**Decisi√≥n:**

* Se elige **SendGrid** como servicio principal para el env√≠o de correos electr√≥nicos transaccionales y de notificaci√≥n en NEXUS.

---

**Sustento:**

* **SendGrid** ofrece una de las **APIs m√°s limpias y documentadas del mercado**, lo cual facilita la integraci√≥n con el backend de NEXUS.
* Permite gestionar **plantillas din√°micas y contenido personalizado** para cada usuario sin depender de un servidor SMTP local.
* Su **alta tasa de entregabilidad y control de reputaci√≥n del dominio** reducen el riesgo de que los correos terminen en la carpeta de spam, algo cr√≠tico para los mensajes de verificaci√≥n y restablecimiento de contrase√±as.

---
# Decision 6

Excelente üöÄ Aqu√≠ tienes la **ADR completa** para la decisi√≥n de implementar **notificaciones push con Expo Notifications**, manteniendo la misma estructura profesional que las decisiones anteriores (Stripe, S3 y SendGrid) y adaptada al contexto de **NEXUS**.

---

### **Decisi√≥n 6 (Sistema de Notificaciones Push)**

**T√≠tulo:**

* Elecci√≥n del sistema de notificaciones push entre **Expo Notifications**, **Firebase Cloud Messaging (FCM)** y **OneSignal** para la aplicaci√≥n m√≥vil de NEXUS.

---

**Contexto:**
La aplicaci√≥n **NEXUS**, disponible en versi√≥n m√≥vil (desarrollada con **React Native/Expo**), necesita implementar un sistema de **notificaciones push** para mejorar la interacci√≥n y retenci√≥n de usuarios.

Estas notificaciones informar√°n a los usuarios sobre:

* Nuevas colaboraciones o comentarios en sus ideas.
* Solicitudes de uni√≥n a proyectos.
* Recompensas disponibles o confirmaciones de pago.
* Recordatorios y actualizaciones de la comunidad.

El sistema debe ser **confiable, multiplataforma (iOS y Android)**, f√°cil de integrar con el stack tecnol√≥gico actual (React Native + backend en Node.js), y permitir un **control centralizado desde el servidor**, sin requerir configuraciones complejas de tokens individuales.

Adem√°s, el equipo busca minimizar la gesti√≥n manual de certificados o configuraciones separadas por plataforma, dado que la app a√∫n est√° en fase de crecimiento.

---

**Alternativas:**

1. **Expo Notifications**

   * Servicio integrado dentro del ecosistema **Expo**.
   * Simplifica la configuraci√≥n de notificaciones sin necesidad de manipular certificados nativos o Google Services.
   * Compatible tanto con **iOS como Android**, utilizando un **√∫nico token de dispositivo (Expo Push Token)**.
   * Permite env√≠o directo desde el backend mediante la **Expo Push API**.
   * Excelente documentaci√≥n y soporte para integraci√≥n con Node.js.
   * Ofrece manejo de notificaciones locales y programadas.
   * Ideal para equipos que desarrollan en Expo sin ejectuar procesos nativos.

2. **Firebase Cloud Messaging (FCM)**

   * Servicio gratuito y altamente confiable de Google.
   * Permite una integraci√≥n m√°s personalizada, pero requiere **configuraci√≥n nativa** en Android y iOS.
   * M√°s flexible en entornos fuera de Expo (bare React Native o apps nativas).
   * Ofrece m√©tricas b√°sicas y segmentaci√≥n de usuarios mediante Firebase Analytics.
   * Integraci√≥n m√°s compleja si no se utiliza el SDK nativo.

3. **OneSignal**

   * Plataforma completa con panel de control visual y API de integraci√≥n.
   * Soporta FCM y APNs (Apple) bajo una misma interfaz.
   * Ideal para notificaciones de marketing, segmentaci√≥n avanzada y automatizaci√≥n.
   * Plan gratuito con limitaciones y planes de pago escalables.
   * Requiere instalaci√≥n de SDK nativo y configuraci√≥n en cada plataforma, lo que puede generar **dependencia fuera de Expo**.
   * Puede incluir branding o limitaciones de control en la versi√≥n gratuita.

---

**Criterios de Elecci√≥n:**

* **Compatibilidad con Expo y React Native**.
* **Facilidad de integraci√≥n y mantenimiento**.
* **Control desde backend** mediante API REST.
* **Soporte multiplataforma (Android e iOS)**.
* **Costo y escalabilidad del servicio.**
* **Disponibilidad de documentaci√≥n y comunidad activa.**
* **Capacidad para enviar notificaciones personalizadas y programadas.**

---

**Decisi√≥n:**

* Se elige **Expo Notifications** como sistema principal de env√≠o y recepci√≥n de notificaciones push en la aplicaci√≥n m√≥vil NEXUS.

---

**Sustento:**

* **Expo Notifications** ofrece una integraci√≥n directa y sin fricci√≥n con el entorno de desarrollo actual de NEXUS, evitando la complejidad de configuraciones nativas que exigen FCM o OneSignal.
* Su sistema de **Expo Push Tokens** simplifica la gesti√≥n de usuarios y dispositivos, permitiendo que el backend en Node.js env√≠e notificaciones mediante una **API REST sencilla**.
* Permite manejar tanto **notificaciones locales (on-device)** como **remotas (desde servidor)**, cubriendo las necesidades de interacci√≥n y engagement de la app.
* La **documentaci√≥n oficial de Expo** es clara, con soporte para colas, prioridades y agrupaci√≥n de mensajes, lo cual favorece la mantenibilidad.
---

[‚¨ÖÔ∏è Anterior](../4.3/4.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../4.5/4.5.md)