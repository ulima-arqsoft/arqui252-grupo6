> [4. Decisiones Iniciales de Arquitectura](../4.md) ‚Ä∫ [4.1. M√≥dulo 1 / Integrante 1](4.1.md)

# 4.1. M√≥dulo 1 / Integrante 1

## Decisi√≥n 1 (Motor de B√∫squeda)

**T√≠tulo**:

- Elecci√≥n de un Motor de B√∫squeda Especializado para Indexaci√≥n y Consulta de Ideas

**Contexto**:

El M√≥dulo 1 gestiona la b√∫squeda y descubrimiento de ideas. Los usuarios necesitan encontrar iniciativas relevantes mediante palabras clave, filtros m√∫ltiples (categor√≠a, tags, habilidades, estado), ordenamiento y facetado. La b√∫squeda debe ser extremadamente r√°pida (p95 ‚â§ 1s con 10k ideas seg√∫n RF001) y soportar b√∫squeda full-text avanzada con relevancia. El M√≥dulo 4 ya decidi√≥ usar MongoDB como repositorio principal de ideas.

**Alternativas**:

1. **B√∫squeda Directa en MongoDB:**
    - Utilizar √≠ndices de texto de MongoDB y consultas con operadores `$text` y `$regex`.
    - Simplicidad arquitect√≥nica (una sola base de datos), menor overhead operativo.
    - Performance limitada para b√∫squedas full-text complejas, scoring de relevancia b√°sico, facetado ineficiente con m√∫ltiples filtros, dificulta cumplir m√©tricas de p95 ‚â§ 1s con alta concurrencia.

2. **Motor de B√∫squeda Especializado (Elasticsearch/OpenSearch):**
    - Implementar un motor de b√∫squeda distribuido espec√≠ficamente dise√±ado para b√∫squeda full-text, con √≠ndices invertidos optimizados.
    - B√∫squeda full-text avanzada con scoring de relevancia (TF-IDF, BM25), facetado y agregaciones extremadamente eficientes, escalabilidad horizontal nativa, soporte para autocompletado con n-grams.
    - Complejidad arquitect√≥nica adicional (sincronizaci√≥n de datos entre MongoDB y Elasticsearch), overhead operativo de mantener dos sistemas.

3. **Servicio de B√∫squeda como Servicio (Algolia, Typesense):**
    - Utilizar un servicio SaaS especializado en b√∫squeda.
    - Implementaci√≥n r√°pida, excelente performance out-of-the-box, menor overhead operativo.
    - Costos recurrentes significativos a escala, menor control sobre infraestructura, dependencia de terceros.

**Criterios de Elecci√≥n:**

- **Performance de B√∫squeda**: Capacidad de cumplir con m√©tricas estrictas (p95 ‚â§ 1s) bajo carga concurrente.
- **Calidad de Resultados**: Scoring de relevancia avanzado y b√∫squeda full-text robusta.
- **Escalabilidad**: Capacidad de crecer con el volumen de ideas y usuarios sin degradaci√≥n.
- **Facetado Eficiente**: Soporte nativo para agregaciones y conteos por categor√≠as (RF008).

**Decisi√≥n:**

Se elige implementar **Elasticsearch** como motor de b√∫squeda especializado para el M√≥dulo 1.

**Sustento:**

- Elasticsearch proporciona el rendimiento necesario para cumplir con RF001 (p95 ‚â§ 1s) mediante √≠ndices invertidos optimizados y cach√© de consultas frecuentes.
- El scoring de relevancia avanzado (BM25) garantiza resultados de alta calidad en b√∫squedas por palabra clave (HU001).
- Las agregaciones nativas de Elasticsearch son ideales para implementar facetado eficiente (HU011, RF008) con m√≠nima latencia.
- La arquitectura distribuida permite escalar horizontalmente para soportar el crecimiento futuro de NEXUS (ESC-05).
- La sincronizaci√≥n con MongoDB se implementar√° mediante Change Streams, garantizando consistencia eventual sin impacto en la escritura de ideas.

---

## Decisi√≥n 2 (Sistema de Cach√©)

**T√≠tulo**:

- Implementaci√≥n de Cach√© Multicapa para Optimizaci√≥n de B√∫squedas y Autocompletado

**Contexto:**

El M√≥dulo 1 requiere respuestas ultra-r√°pidas para autocompletado (p95 ‚â§ 150ms seg√∫n RF005) y debe optimizar b√∫squedas frecuentes para reducir carga en Elasticsearch. Los usuarios tienden a realizar b√∫squedas similares (t√©rminos populares, categor√≠as frecuentes), lo que genera oportunidades de optimizaci√≥n mediante cach√©.

**Alternativas:**

1. **Sin Cach√© (Consultas Directas a Elasticsearch):**
    - Todas las consultas se ejecutan directamente contra Elasticsearch.
    - Simplicidad arquitect√≥nica, datos siempre actualizados.
    - Mayor latencia en consultas frecuentes, mayor carga en Elasticsearch, dificulta cumplir m√©trica de autocompletado (p95 ‚â§ 150ms), costos m√°s altos de infraestructura.

2. **Cach√© en Memoria de Aplicaci√≥n (In-Memory Cache):**
    - Implementar cach√© local en cada instancia del microservicio usando estructuras de datos en memoria.
    - Latencia m√≠nima (microsegundos), sin dependencias externas.
    - Inconsistencia entre instancias en arquitectura distribuida, memoria limitada por instancia, invalidaci√≥n de cach√© compleja.

3. **Cach√© Distribuida (Redis/Memcached):**
    - Implementar una capa de cach√© distribuida compartida entre todas las instancias del microservicio.
    - Consistencia entre instancias, latencia ultra-baja (sub-milisegundo), escalabilidad independiente, TTL configurable para balance actualizaci√≥n/performance.
    - Dependencia adicional en la arquitectura, complejidad en estrategias de invalidaci√≥n.

**Criterios de Elecci√≥n:**

- **Latencia**: Capacidad de cumplir con p95 ‚â§ 150ms para autocompletado.
- **Consistencia**: Garantizar experiencia uniforme entre todas las instancias del servicio.
- **Escalabilidad**: Capacidad de crecer independientemente del servicio de b√∫squeda.
- **Eficiencia de Recursos**: Reducir carga en Elasticsearch para optimizar costos.

**Decisi√≥n:**

Se elige implementar **Redis** como sistema de cach√© distribuida con estrategia multicapa.

**Sustento:**

- Redis proporciona latencias sub-milisegundo que garantizan cumplir con RF005 (p95 ‚â§ 150ms) para autocompletado, incluso considerando overhead de red.
- La arquitectura distribuida asegura consistencia entre todas las instancias del microservicio de b√∫squeda.
- Se implementar√°n tres niveles de cach√©:
  1. **Cach√© de Autocompletado**: Prefijos frecuentes con TTL corto (5 minutos)
  2. **Cach√© de Resultados**: B√∫squedas frecuentes completas con TTL medio (15 minutos)
  3. **Cach√© de Facetas**: Conteos por categor√≠a/tags con TTL largo (30 minutos)
- La estrategia de invalidaci√≥n usar√° TTL + invalidaci√≥n proactiva v√≠a eventos de publicaci√≥n/actualizaci√≥n de ideas.
- Redis reduce significativamente la carga en Elasticsearch, permitiendo escalar de manera m√°s econ√≥mica.

---

## Decisi√≥n 3 (Estrategia de Sincronizaci√≥n)

**T√≠tulo**:

- Implementaci√≥n de Sincronizaci√≥n As√≠ncrona mediante Event-Driven Architecture para Actualizaci√≥n del √çndice de B√∫squeda

**Contexto:**

El M√≥dulo 1 necesita mantener su √≠ndice de Elasticsearch sincronizado con los datos maestros en MongoDB (M√≥dulo 4). Cada vez que se crea, actualiza o elimina una idea, el √≠ndice de b√∫squeda debe reflejarlo. La sincronizaci√≥n debe ser confiable, escalable y no debe impactar el rendimiento del M√≥dulo 4 (publicaci√≥n de ideas).

**Alternativas:**

1. **Sincronizaci√≥n S√≠ncrona (Dual-Write):**
    - El M√≥dulo 4 escribe simult√°neamente en MongoDB y llama al API del M√≥dulo 1 para actualizar Elasticsearch.
    - Consistencia inmediata, implementaci√≥n directa.
    - Acoplamiento fuerte entre m√≥dulos, mayor latencia en operaciones de escritura del M√≥dulo 4, riesgo de inconsistencia si falla una escritura, afecta disponibilidad (si Elasticsearch cae, no se pueden publicar ideas).

2. **Sincronizaci√≥n As√≠ncrona via Polling:**
    - El M√≥dulo 1 consulta peri√≥dicamente MongoDB buscando cambios recientes.
    - Desacoplamiento entre m√≥dulos, no impacta escritura del M√≥dulo 4.
    - Latencia de sincronizaci√≥n (seg√∫n intervalo de polling), ineficiente (consultas constantes aunque no haya cambios), dificulta garantizar orden de eventos.

3. **Sincronizaci√≥n As√≠ncrona via Event Streaming (MongoDB Change Streams + Message Queue):**
    - MongoDB emite eventos de cambio (Change Streams) que se publican en una cola de mensajes (RabbitMQ/Kafka), el M√≥dulo 1 consume estos eventos y actualiza Elasticsearch.
    - Desacoplamiento total, latencia baja (milisegundos-segundos), orden garantizado de eventos, escalabilidad independiente, resiliencia (cola act√∫a como buffer).
    - Consistencia eventual (no inmediata), complejidad arquitect√≥nica adicional.

**Criterios de Elecci√≥n:**

- **Desacoplamiento**: Independencia entre m√≥dulos para facilitar evoluci√≥n y mantenimiento.
- **Rendimiento del M√≥dulo 4**: No impactar la latencia de publicaci√≥n de ideas.
- **Confiabilidad**: Garantizar que todos los cambios se sincronicen eventualmente.
- **Latencia de Sincronizaci√≥n**: Balance entre inmediatez y complejidad.

**Decisi√≥n:**

Se elige **Sincronizaci√≥n As√≠ncrona via Event Streaming** utilizando MongoDB Change Streams + RabbitMQ.

**Sustento:**

- MongoDB Change Streams permite detectar cambios en tiempo real sin polling, con overhead m√≠nimo.
- RabbitMQ act√∫a como buffer confiable que garantiza entrega de eventos incluso si el M√≥dulo 1 est√° temporalmente ca√≠do (ESC-03).
- El desacoplamiento total permite que el M√≥dulo 4 opere independientemente del estado de Elasticsearch, mejorando disponibilidad general.
- La latencia de sincronizaci√≥n (t√≠picamente < 2 segundos) es aceptable para el caso de uso de NEXUS.
- Patrones de reintentos y dead-letter queues garantizan confiabilidad ante fallos temporales.
- La arquitectura permite escalar consumidores del M√≥dulo 1 independientemente seg√∫n la carga.

---

## Decisi√≥n 4 (Control de Acceso y Visibilidad)

**T√≠tulo**:

- Implementaci√≥n de Filtrado de Visibilidad a Nivel de Consulta con Cach√© por Usuario

**Contexto:**

El M√≥dulo 1 debe respetar la visibilidad de las ideas (p√∫blica/privada/compartida) seg√∫n RF007 y ESC-04. Cada b√∫squeda debe filtrar resultados seg√∫n los permisos del usuario autenticado. La verificaci√≥n de permisos no debe degradar significativamente el rendimiento de b√∫squeda (p95 ‚â§ 1s).

**Alternativas:**

1. **Filtrado Post-Consulta en Aplicaci√≥n:**
    - Elasticsearch devuelve todos los resultados, la aplicaci√≥n verifica permisos y filtra.
    - Implementaci√≥n simple en l√≥gica de aplicaci√≥n.
    - Ineficiente (se traen datos que se descartar√°n), paginaci√≥n incorrecta (p√°gina incompleta si se filtran resultados), no cumple m√©tricas de rendimiento a escala.

2. **Filtrado a Nivel de Consulta con ACL en √çndice:**
    - Cada documento en Elasticsearch incluye campos de ACL (Access Control List), las consultas incluyen filtros booleanos sobre estos campos.
    - Eficiente (Elasticsearch filtra nativamente), paginaci√≥n correcta, rendimiento √≥ptimo.
    - √çndice crece con informaci√≥n de permisos, mayor complejidad en sincronizaci√≥n si cambian permisos.

3. **Servicio de Autorizaci√≥n Externo:**
    - Llamar a un servicio de autorizaci√≥n centralizado para cada resultado.
    - Centralizaci√≥n de l√≥gica de permisos, auditor√≠a completa.
    - Latencia adicional por cada llamada de red, dificulta cumplir m√©tricas de rendimiento, mayor complejidad operacional.

**Criterios de Elecci√≥n:**

- **Rendimiento**: Mantener m√©tricas de b√∫squeda (p95 ‚â§ 1s) con filtrado de visibilidad.
- **Correcci√≥n**: Garantizar que el 100% de ideas respeten visibilidad (ESC-04).
- **Escalabilidad**: Soportar millones de ideas con diferentes niveles de visibilidad.
- **Simplicidad Operacional**: Minimizar dependencias externas en ruta cr√≠tica.

**Decisi√≥n:**

Se elige **Filtrado a Nivel de Consulta con ACL en √çndice** combinado con cach√© de permisos de usuario.

**Sustento:**

- Elasticsearch realiza el filtrado de manera nativa y eficiente mediante filtros booleanos, sin impacto significativo en rendimiento.
- Cada documento indexado incluye campos: `visibility` (public/private/shared), `owner_id`, `shared_with[]` (lista de user_ids).
- Las consultas incluyen autom√°ticamente cl√°usulas: `(visibility:public OR owner_id:{user_id} OR shared_with:{user_id})`.
- Se implementa cach√© Redis de permisos de usuario (grupos/organizaciones) con TTL de 5 minutos para reducir complejidad de consultas.
- La sincronizaci√≥n v√≠a Change Streams actualiza ACLs en Elasticsearch cuando cambian permisos de ideas.
- Esta arquitectura garantiza 100% de correcci√≥n en visibilidad (ESC-04) manteniendo rendimiento √≥ptimo.

---

## Decisi√≥n 5 (Observabilidad y Telemetr√≠a)

**T√≠tulo**:

- Implementaci√≥n de Sistema de Telemetr√≠a Distribuida para Monitoreo de B√∫squedas y Optimizaci√≥n Basada en Datos

**Contexto:**

El M√≥dulo 1 requiere telemetr√≠a completa seg√∫n RF009 y ESC-10 para monitorear rendimiento, detectar problemas temprano y optimizar la experiencia de b√∫squeda mediante an√°lisis de patrones de uso. Los datos de telemetr√≠a deben capturarse sin impactar la latencia de b√∫squeda.

**Alternativas:**

1. **Logging B√°sico en Archivos:**
    - Escribir eventos de b√∫squeda en archivos de log locales.
    - Simplicidad, bajo overhead inicial.
    - Dificulta an√°lisis agregado, sin m√©tricas en tiempo real, problemas de almacenamiento a escala, no permite alertas proactivas.

2. **Sistema de M√©tricas (Prometheus) + Logging Estructurado (ELK Stack):**
    - M√©tricas de rendimiento en Prometheus, eventos detallados en Elasticsearch via Logstash/Fluentd.
    - Separaci√≥n de concerns (m√©tricas vs logs), excelente para an√°lisis y alertas, ecosistema maduro.
    - Complejidad operacional de m√∫ltiples sistemas, posible duplicaci√≥n de almacenamiento.

3. **Plataforma de Observabilidad Unificada (Datadog, New Relic, Elastic APM):**
    - Soluci√≥n todo-en-uno para m√©tricas, logs y traces distribuidos.
    - Implementaci√≥n r√°pida, correlaci√≥n autom√°tica, menor overhead operacional.
    - Costos recurrentes significativos a escala, dependencia de terceros, menor control sobre datos.

**Criterios de Elecci√≥n:**

- **Visibilidad Completa**: Capturar 100% de eventos de b√∫squeda seg√∫n RF009.
- **Performance**: Overhead m√≠nimo en latencia de b√∫squeda (< 5ms).
- **An√°lisis en Tiempo Real**: M√©tricas y alertas inmediatas ante degradaci√≥n.
- **Cost-Effectiveness**: Balance entre capacidad y costo operacional.

**Decisi√≥n:**

Se elige implementar **Sistema de M√©tricas (Prometheus) + Logging Estructurado (ELK Stack)** con sampling inteligente.

**Sustento:**

- **Prometheus** captura m√©tricas de rendimiento en tiempo real (latencias p50/p95/p99, throughput, tasa de errores) con overhead m√≠nimo.
- **Elasticsearch (v√≠a Filebeat/Logstash)** almacena eventos detallados de b√∫squeda (`search_performed`, `result_click`) para an√°lisis hist√≥rico.
- Se implementa **sampling inteligente**: 
  - 100% de b√∫squedas generan m√©tricas (Prometheus)
  - 100% de b√∫squedas lentas (> 1s) se loggean detalladamente
  - 10% de b√∫squedas normales se loggean para an√°lisis de patrones
- **Grafana** proporciona dashboards en tiempo real y alertas configurables.
- El sistema captura: t√©rminos de b√∫squeda (anonimizados), filtros aplicados, tiempo de respuesta, resultados devueltos, clicks en resultados.
- Esta arquitectura permite optimizaci√≥n basada en datos (identificar b√∫squedas lentas, t√©rminos populares para precomputar, etc.) cumpliendo ESC-10.

---

[üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../4.2/4.2.md)