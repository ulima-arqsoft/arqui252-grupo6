> [4. Decisiones Iniciales de Arquitectura](../4.md) ‚Ä∫ [4.2. M√≥dulo 2 / Integrante 2](4.2.md)

# 4.2. M√≥dulo 2 / Integrante 2

## Decisi√≥n 1: Modelo de Coordinaci√≥n

### T√≠tulo
**Elecci√≥n entre Comunicaci√≥n en Tiempo Real mediante WebSockets vs Peticiones REST Tradicionales para la Coordinaci√≥n de Colaboradores**

El backend se desarrolla en **Node.js con Express**, y el frontend en **React**, ambos compatibles con **REST API** y **WebSockets (Socket.IO)**, lo que plantea la necesidad de definir el modelo de coordinaci√≥n principal.

### Alternativas
1. **REST API Tradicional (HTTP)**  
   - Comunicaci√≥n basada en solicitudes cliente-servidor independientes.  
   - Cada acci√≥n (enviar mensaje, aceptar solicitud, etc.) requiere una llamada HTTP.  
   - F√°cil de implementar, pero con mayor latencia.  
   - No ofrece comunicaci√≥n bidireccional.

2. **Comunicaci√≥n en Tiempo Real mediante WebSockets (Socket.IO)**  
   - Conexi√≥n persistente cliente-servidor.  
   - Comunicaci√≥n bidireccional ideal para mensajer√≠a y notificaciones.  
   - Baja latencia y transmisi√≥n inmediata de eventos.  
   - Integraci√≥n nativa con Express y React.

### Criterios de Elecci√≥n
- **Latencia y fluidez**: comunicaci√≥n instant√°nea.  
- **Escalabilidad**: m√∫ltiples sesiones simult√°neas.  
- **Compatibilidad t√©cnica**: integraci√≥n con Node.js y React.  
- **Experiencia de usuario**: interacci√≥n natural, sin recargas.  
- **Mantenibilidad**: extensi√≥n futura hacia notificaciones o videollamadas.

### Decisi√≥n
Se implementar√° **WebSockets (Socket.IO)** para habilitar comunicaci√≥n en tiempo real entre los colaboradores dentro del m√≥dulo.

### Sustento
- Permite mensajes instant√°neos (HU019) y notificaciones inmediatas (HU018).  
- Soporta reconexi√≥n autom√°tica y eventos personalizados (ESC-21).  
- Integra sin fricci√≥n con Express y React, conservando la arquitectura modular.  
- Baja latencia promedio (<200 ms).

### Conclusi√≥n T√©cnica
**Stack:** Node.js + Express + Socket.IO  
**Atributos reforzados:** Disponibilidad, Interoperabilidad, Usabilidad y Rendimiento.  

---

## ‚öôÔ∏è Decisi√≥n 2: Estrategia de Persistencia de Mensajes

### T√≠tulo
**Elecci√≥n entre Almacenamiento Temporal en Memoria (Redis) vs Almacenamiento Permanente en Base de Datos (SQL Server)**

### Contexto
El M√≥dulo 2 requiere guardar los mensajes enviados entre colaboradores para permitir su recuperaci√≥n en caso de desconexi√≥n (ESC-21) y mantener trazabilidad del historial (ESC-28).  
Se evalu√≥ si los mensajes deben almacenarse temporalmente en memoria o persistirse directamente en la base de datos principal.

### Alternativas
1. **Almacenamiento Temporal en Memoria (Redis)**  
   - Alta velocidad de lectura/escritura.  
   - Ideal para colas de mensajes activos y sesiones abiertas.  
   - No garantiza persistencia a largo plazo.  

2. **Almacenamiento Permanente en SQL Server**  
   - Registro duradero de todas las conversaciones.  
   - Mayor latencia de escritura.  
   - Escalabilidad limitada bajo alta concurrencia.

### Criterios de Elecci√≥n
- **Rendimiento:** velocidad en la entrega de mensajes activos.  
- **Trazabilidad:** necesidad de guardar el historial del chat.  
- **Disponibilidad:** evitar p√©rdida de mensajes durante fallas o reconexiones.  
- **Costo de mantenimiento:** simplicidad de integraci√≥n con el backend existente.

### Decisi√≥n
Se adopta una **estrategia h√≠brida**:  
- Redis para mensajes activos en tiempo real.  
- SQL Server para almacenamiento hist√≥rico mediante sincronizaci√≥n peri√≥dica.

### Sustento
- Redis reduce la latencia de env√≠o/recepci√≥n (ESC-24).  
- SQL Server conserva los mensajes de manera trazable (ESC-28).  
- En caso de falla, los mensajes pendientes en Redis se sincronizan autom√°ticamente.

### Conclusi√≥n T√©cnica
**Stack:** Redis + SQL Server  
**Atributos reforzados:** Rendimiento, Trazabilidad y Disponibilidad.  

---

##  Decisi√≥n 3: Control de Acceso y Roles

### T√≠tulo
**Implementaci√≥n de Autenticaci√≥n JWT con Middleware de Roles vs Sesiones de Usuario Tradicionales**

### Contexto
Los colaboradores deben acceder √∫nicamente a los chats en los que participan.  
El sistema necesita validar roles (creador, colaborador, moderador) y proteger la comunicaci√≥n contra accesos no autorizados (ESC-25, ESC-29).

### Alternativas
1. **Sesiones de Usuario Tradicionales (Cookies/Session Storage)**  
   - Gesti√≥n de sesi√≥n en servidor.  
   - Requiere sincronizaci√≥n compleja en m√∫ltiples instancias.  
   - Escalabilidad limitada.  

2. **Autenticaci√≥n JWT con Middleware de Roles**  
   - Tokens firmados enviados en cada petici√≥n WebSocket o REST.  
   - Validaci√≥n descentralizada sin estado (stateless).  
   - Escalable y compatible con microservicios.

### Criterios de Elecci√≥n
- **Seguridad:** validaci√≥n robusta sin exponer credenciales.  
- **Escalabilidad:** sesiones distribuidas entre m√∫ltiples nodos.  
- **Mantenibilidad:** f√°cil de extender a nuevos tipos de rol.  
- **Compatibilidad:** integraci√≥n con middleware de Express y Socket.IO.

### Decisi√≥n
Implementar **autenticaci√≥n basada en JWT** y **middleware de roles personalizados** para cada canal de colaboraci√≥n.

### Sustento
- Permite identificar usuarios y roles sin mantener sesiones persistentes.  
- Controla permisos por canal y acci√≥n (HU022, ESC-25).  
- Facilita la revocaci√≥n inmediata al abandonar el proyecto (ESC-29).  
- Cumple con los requisitos de seguridad y escalabilidad distribuidas.

### Conclusi√≥n T√©cnica
**Stack:** Express + JWT + Middleware de Roles  
**Atributos reforzados:** Seguridad, Escalabilidad y Mantenibilidad.  

---

##  Decisi√≥n 4: Sistema de Notificaciones Inteligentes

### T√≠tulo
**Elecci√≥n entre Notificaciones Push en Tiempo Real vs Notificaciones Agrupadas por Prioridad**

### Contexto
Los colaboradores activos en m√∫ltiples proyectos reciben notificaciones de nuevos mensajes, menciones y solicitudes (HU018, ESC-26).  
Un exceso de alertas simult√°neas puede generar saturaci√≥n de la interfaz y disminuir la usabilidad.

### Alternativas
1. **Notificaciones Push Inmediatas**  
   - Cada evento genera una alerta instant√°nea.  
   - Alta inmediatez pero puede saturar la experiencia.  

2. **Notificaciones Agrupadas por Prioridad (Batch)**  
   - Se agrupan mensajes y eventos de baja prioridad.  
   - Mejora la experiencia, reduce ruido informativo.  
   - Requiere un sistema de clasificaci√≥n y almacenamiento temporal.

### Criterios de Elecci√≥n
- **Usabilidad:** reducir interrupciones y distracciones.  
- **Rendimiento:** disminuir el n√∫mero de eventos simult√°neos.  
- **Escalabilidad:** manejar notificaciones de cientos de chats activos.  

### Decisi√≥n
Adoptar **notificaciones agrupadas por prioridad**, enviadas en lotes seg√∫n relevancia (menciones directas, invitaciones o mensajes generales).

### Sustento
- Reduce el ruido informativo (ESC-26).  
- Optimiza recursos del servidor y mejora la experiencia.  
- Permite personalizar alertas por canal o tipo de mensaje.  

### Conclusi√≥n T√©cnica
**Stack:** Redis Streams + Socket.IO Notifications  
**Atributos reforzados:** Usabilidad, Rendimiento y Escalabilidad.  

---

##  Decisi√≥n 5: Escalabilidad Horizontal del Chat

### T√≠tulo
**Elecci√≥n entre Servidor √önico Centralizado vs Escalado Horizontal con Balanceador de Carga**

### Contexto
El m√≥dulo debe soportar miles de usuarios concurrentes (ESC-30).  
Un servidor √∫nico puede limitar la capacidad de respuesta y provocar ca√≠das bajo alta demanda.

### Alternativas
1. **Servidor √önico Centralizado**  
   - Simplicidad de implementaci√≥n.  
   - Escalabilidad limitada y riesgo de sobrecarga.  

2. **Escalado Horizontal con Balanceador de Carga (Nginx/PM2 Cluster)**  
   - Distribuye las conexiones WebSocket entre m√∫ltiples instancias.  
   - Mejora la disponibilidad y tolerancia a fallos.  
   - Requiere una configuraci√≥n inicial m√°s compleja.

### Criterios de Elecci√≥n
- **Escalabilidad:** manejar picos de usuarios concurrentes.  
- **Disponibilidad:** evitar ca√≠das del servicio.  
- **Rendimiento:** mantener baja latencia en todos los nodos.  

### Decisi√≥n
Implementar **escalado horizontal con balanceador de carga Nginx** y **m√≥dulo de clustering de Node.js (PM2)**.

### Sustento
- Garantiza alta disponibilidad durante picos (ESC-30).  
- Distribuye la carga equitativamente entre instancias.  
- Facilita el mantenimiento y despliegue sin downtime.  

### Conclusi√≥n T√©cnica
**Stack:** Node.js Cluster + Nginx + Redis Adapter  
**Atributos reforzados:** Escalabilidad, Disponibilidad y Rendimiento. 

[‚¨ÖÔ∏è Anterior](../4.1/4.1.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../4.3/4.3.md)



